{"/cache/redis/":{"data":{"":"Redis(Remote Dictionary Server) 是一个开源（BSD 许可）的内存数据结构存储系统，可以用作数据库、缓存和消息代理。它支持多种数据结构：\n字符串（strings) 散列（hashes) 列表（lists） 集合（sets） 有序集合（sorted sets） 优点 轻量级，基于内存的键值对数据库 支持数据的持久化，这是Redis重要特点 支持分布式特性 支持主从复制提高读写性能，支持哨兵、集群保证高可用 "},"title":"Redis"},"/cache/redis/basic/":{"data":{"":"安装与卸载 源码安装\nwget 软件包 解压 sudo tar xzf redis 7.0.19.tar.gz 编译 sudo make 编译测试 sudo make test 安装 sudo make install 服务命令\n开启redis后，继续使用终端 redis-server /usr/local/redis/redis.conf \u0026 关闭服务 redis-cli shutdown\n默认RDB报错：该用户保存快照所处的文件，权限不够，可以将redis的文件夹的权限更改，或者新建一个rdb目录文件，将这个新建的文件夹权限修改成 777 ，然后在redis.conf中，将rdb文件保存目录修改成新建的文件夹目录\nmkdir myRedis sudo chmod _R 777 myRedis sudo vi redis.conf ## 将 dir ./ 修改成 dir /myRedis/ 日志路径错误\nredis.conf默认的 logfile 为 “” 修改成一个文件目录即可，可以自己新建一个日志目录 logfile “/usr/local/redis/redis_log” 简介 是一个内存数据库 ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。 支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。 支持数据的备份，即master-slave模式的数据备份。 原子性操作 配置 ==当更改了配置，需要重启，启动时需要指定使用的redis配置文件==\n命令 config set key value（有些配置运行期不可更改） config get key"},"title":"基础知识"},"/cache/redis/datatype/":{"data":{"":"String 是Redis最基本的数据类型，特点是二进制安全，可以存储任何类型的数据，包括文本、数字、图像、序列化等，存储最大大小为512MB\nset redis\u003e set key \"Hello World\" ex 10 \"OK\" redis\u003e setrange key 6 \"Redis\" (integer) 11 redis\u003e get key \"Hello Redis\" redis\u003e mset k1 v1 k2 v2 \"OK\" redis\u003e append k1 song (integer) 6 redis\u003e get k1 \"v1song\" incr/decr redis\u003e set num 1 \"OK\" redis\u003e incr num (integer) 2 redis\u003e incrby num 10 (integer) 12 redis\u003e incrbyfloat num 0.1 \"12.1\" --- decr只能操作整数 redis\u003e decr num (integer) 1 redis\u003e decrby num 10 (integer) 0 get redis\u003e set key \"Hello World\" \"OK\" redis\u003e get key \"Hello World\" redis\u003e get nonexistentkey (nil) redis\u003e getrange key 0 4 \"Hello\" strlen redis\u003e set key \"Hello World\" \"OK\" redis\u003e strlen key (integer) 11 lcs 最长公共子序列，时间复杂度O(n*m)"},"title":"数据类型"},"/cache/redis/persistence/":{"data":{"":"这是Redis作为内存数据库的特点 能够将存储在内存中的数据保存到文件中，以便下次使用 方式有两种：RDB和AOF，默认为RDB持久化 配置 rdb_last_bgsave_status：上次bgsave 执行结果，可以用于发现bgsave错误 rdb_last_bgsave_time_sec：上次bgsave执行时间（单位是s），可以用于发现bgsave是否耗时过长 aof_enabled：AOF是否开启 aof_last_rewrite_time_sec：上次文件重写执行时间（单位是s），可以用于发现文件重写是否耗时过长 aof_last_bgrewrite_status：上次bgrewrite执行结果，可以用于发现bgrewrite错误 aof_buffer_length和aof_rewrite_buffer_length： aof缓存区大小和aof重写缓冲区大小 aof_delayed_fsync：AOF追加阻塞情况的统计 no-appendfsync-on-rewrite no：当重写时是否禁止同步 RDB 存储方式：是将数据存放在文件中 默认文件名：dump.rdb 配置 #自动触发 save m n #当bgsave出现错误时，是否停止执行写命令；yes可以及时发现问题 stop-writes-on-bgsave-error yes #RDB文件压缩 rdbcompression yes #RDB文件的校验 rdbchecksum yes #文件名 dir #存储路径 dbfilename dump66.rdb # 将数据集压缩成LZF rdbcompression yes #在主从复制的时候，删除没有开启持久化的从节点的RDB文件 rdb-del-sync-files no 触发RDB持久化方式： 命令手动触发 save：会阻塞redis服务器进程，阻塞时不会处理任何命令，直至持久化完成 bgsave：后台持久化，主进程会fork一个子进程进行持久化 自动触发 可以在配置文件里定义在什么时间内多少次修改就会自动持久化 主从复制时，从节点执行全量复制操作，主节点会执行bgsave命令，将rdb文件发送给从节点 执行shutdown命令，自动执行持久化 执行flushall命令，自动执行持久化 执行流程（ bgsave ） save命令使用主进程\n主进程首先判断后台是否正在执行持久化操作，如果在执行则直接返回，否则继续 然后 fork一个子进程，使子进程执行持久化的操作，fork过程，主进程阻塞 等待返回“background saving started”，主进程不再阻塞，可以响应其他命令 子进程生成RDB文件后，根据父进程内存快照生成临时快照文件，完成后对原有文件进行原子替换 因为redis启动时，会加载RDB的数据，所以原数据是存在的，在执行该命令时，就可以直接很据内存快照生成RDB文件了。 信号通知主进程，主进程更新统计信息 RDB文件 二进制文件\n文件的存储名和路径："},"title":"持久化"},"/cache/redis/replication/":{"data":{"":"概念 redis的高可用技术 复制：复制数据 将一台redis服务器的数据，复制到其他的redis服务器。前者称为主节点(master)，后者称为从节点(slave)； 数据的复制是单向的，只能由主节点到从节点。 默认情况下，每台Redis服务器都是主节点 且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点，一对多的。 当redis服务崩溃，有一些自动重启工具，特别的是持久化关闭，则内存的数据集为空，也会导致从节点的数据集为空 作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。 故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。 负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。 高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。 使用 注意：主从复制的关系操作都是由从节点发起的，和主节点没有关系\n开启 配置文件 replicaof\n可以在当前机器的配置文件中配置自己的主节点：\nreplicaof \u003c主节点IP\u003e \u003c主节点redis的端口号\u003e\n客户端命令 slaveof ip port\n临时设置，主从设置只能由从节点来发出\n启动服务命令redis-server redis.conf —slaveof ip port\n断开复制 命令：slaveof no one 命令查看主从复制的信息： info replication\n主节点信息 role:master //当前机器的角色：主节点、从节点 connected_slaves:0//指连接到当前机器的节点，有多少个从节点（孩子） #表示该节点的从节点信息 slave0:ip=127.0.0.1,port=63991,state=online,offset=238,lag=1 slave1:ip=127.0.0.1,port=63992,state=online,offset=238,lag=0 master_failover_state:no-failover master_replid:6ddb8b10ff26f48ca9d1ec9b4bb6a90e3acd4ca3//指该节点的主节点ID，默认是自己的ID master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 //复制积压缓冲区的大小（字节） repl_backlog_first_byte_offset:0 //第一个字节的偏移量 repl_backlog_histlen:0 从节点信息 role:slave//当前身份为从节点 master_host:127.0.0.1 //主节点的IP master_port:6399 //主节点的端口号 master_link_status:up //连接的状态 master_last_io_seconds_ago:4 master_sync_in_progress:0 slave_read_repl_offset:10411 slave_repl_offset:10411 //从节点保存的复制偏移量 slave_priority:100 slave_read_only:1 replica_announced:1 connected_slaves:0 master_failover_state:no-failover master_replid:77f8706123a909da8065a99c210388c1656b3afa master_replid2:0000000000000000000000000000000000000000 master_repl_offset:10411 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:10161 //第一次连接的数据偏移量 repl_backlog_histlen:251 注意！！！"},"title":"主从复制"},"/cache/redis/sentinel/":{"data":{"":"哨兵(sentinel)目的 解决主从复制的故障恢复问题 功能 监控（Monitoring）：哨兵会不断地检查主节点和从节点是否运作正常。 自动故障转移（Automatic failover）：当主节点不能正常工作时，哨兵会开始自动故障转移操作，选择失效的主节点的其中一个从节点晋升为新的主节点，并把原来主节点的从节点复制到这个新的主节点。 配置提供者（Configuration provider）：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。 通知（Notification）：哨兵可以将故障转移的结果发送给客户端。 架构 哨兵节点：多个哨兵节点可以组成一个哨兵系统，是一个特殊的节点，不能存放数据 数据节点：主节点和从节点 部署、使用 架构： 一主两从：6399，63991，63992 （主从复制）\n三个哨兵：29379，26380，26381\n哨兵节点的配置文件（sentinel.conf） protected-mode no port 26379 daemonize no pidfile /var/run/redis-sentinel.pid #为空的时候，日志打到标准输出设备，但是如果是守护进程，则打到/dev/null文件上 logfile \"\" #sentinel announce-ip \u003cip\u003e #sentinel announce-port \u003cport\u003e #工作目录 dir /tmp #该哨兵监控主节点 host为127.0.0.1端口为6379，quorum(法定人数)，至少有quorum个哨兵节点认为该主节点down的时候，才进行故障转移 #不用配置从节点，会自动检测，然后重写该配置文件 #格式：sentinel monitor \u003cmaster-name\u003e \u003cip\u003e \u003credis-port\u003e \u003cquorum\u003e sentinel monitor mymaster 127.0.0.1 6379 2 #配置主节点的身份验证，该密码会用在主从节点，所以要保证主从节点的密码一致，没有配置身份验证的节点则跳过 #sentinel auth-pass \u003cmaster-name\u003e \u003cpassword\u003e #sentinel auth-user \u003cmaster-name\u003e \u003cusername\u003e #判断主观下线（subjectively）Default is 30 seconds. sentinel down-after-milliseconds mymaster 30000 --------------------------------ACL----------------------- #ACL LOG acllog-max-len 128 #aclfile /etc/redis/sentinel-users."},"title":"哨兵"},"/datastruct/list/":{"data":{"":"数组 数组是一种线性数据结构，用连续的内存空间存储相同类型的元素，使用索引来访问每一个元素。一般都是通过一个变量指向数组开辟空间的首地址，之后进行空间位置的增加来顺序访问元素。\nint a=new int[10]; //访问 a[1]=0 System.out.println(a[1]); 访问数组的元素\n时间复杂度O(1)，因为可以直接获得要访问的元素的位置 一般都是索引来访问，索引也是偏移量，那么访问的地址为 地址=首地址+元素长度*索引 还有c语言的指针，通过指针的移动来访问元素，这速度会更快。 插入和删除\n若进行中间位置插入，需要移动后续元素，且最后一个元素可能会丢失 删除操作同理，要保证元素是顺序的 遍历\n时间复杂度O(N) 扩容\n因为在开辟一个数组的时候，数组大小需要固定 在系统层面，如果不固定大小，会浪费内存空间，不知道需要预留多少空间。若要支持扩容，如果后续空间不够，还需要从空闲列表中找出有充足且连续大小的内存空间，当然这个需要O(N)的时间复杂度，进行元素的复制。 链表 链表也是一个线性顺序的数据结构，不同与数组，是依靠元素中的指针来维护的，这个指针就是指向下一个元素的内存空间，所以，当内存空间不连续的时候挺有用的。但是在空间大小方面，比列表占用的多，因为维护了指针。\nclass Node{ private Object element; private Node next; private Node prior; //辅助数据 } 在创建时，创建元素后，串联在一起就ok 删除时，将被删除元素的前一个元素的后继指针指向其下一个元素，需要考虑被删元素的空间，Java中可以将变量指向null 插入时，操作指针指向即可 访问和查找时，时间复杂度O(N)，所以链表不适合访问和查找 链表常用类型\n单链表 双向链表 循环链表 双向循环链表 技巧：哨兵，在头部引入一个空节点，当做一个哑对象，用来简化代码，降低时间复杂度的常数因子。"},"title":"数组和链表"},"/datastruct/math/":{"data":{"":"幂运算 幂(power)运算，如 a^m，表示a的n次方，也就是n个a相乘。\n常规算法如：\npublic static int power(int n, int m) { int result = 1; for (int i = 0; i \u003c m; i++) { result *= n; } return result; } 但是这种常规算法复杂度太高了，算法复杂度O(n)。\n快速幂算法---二进制分解算法\n这个算法可以在log(n)的复杂度下解决问题。\n具体是：将指数分解成二进制计算，根据指数的二进制位的值，来判断result是否要继续计算，如下图，当11分解成二进制1011时，最终也就是5^8 * 5^2 * 5^1= 5^11，所以就是在124的位置的时候进行累乘即可。 代码实现：\npublic static int quick_power(int base, int power) { int result = 1; while (power \u003e 0) { if ((power \u0026 1) == 1) { result *= base; } base *= base; power \u003e\u003e= 1; } return result; } 结合余数 当幂运算结合着求余数运算时，可以在每一步累乘的时候直接进行余数运算，减少数的大小，不会影响最终余数结果"},"title":"数学"},"/datastruct/stack-queue/":{"data":{"":"栈 stack 栈是一个线性数据结构，具有后进先出的特点，即LIFO，可以由数组和链表实现\n操作\n入栈，push 出栈，pop 栈的应用，比如编程的方法递归调用，浏览器浏览历史的前进后退，还有常见的算法比如表达式求值，进制计算\n队列 queue 队列也是一个线性数据结构，具有先进先出的特点，即FIFO，可以由数组和链表实现\n操作\n入队 出队 重要的点：在使用数组维护时，一般维护一个队头索引，队尾索引\n队列的应用比较常用，先进先出的特点正如平常生活中的排队，可以做一些任务的积攒，进行公平处理，也就是一些任务队列。"},"title":"栈和队列"},"/devframe/nginx/":{"data":{"":"使用 压缩包，去官网下载 nginx 解压，tar -zxvf nginx-1.20.1.tar.gz 进入目录，cd nginx-1.20.1 配置，./configure 编译，make 安装，sudo make install 启动，sudo /usr/local/nginx/sbin/nginx 访问，curl localhost:80 停止，sudo /usr/local/nginx/sbin/nginx -s stop 卸载，sudo rm -rf /usr/local/nginx "},"title":"Nginx"},"/devframe/schedule/xxl-job/":{"data":{"":"xxl-job 是一个分布式任务调度平台，可以轻松实现分布式任务调度。 xxl-job 支持 Linux、Windows、Mac 等操作系统，并且支持 Java、Python、Shell 等语言，并且支持 MySQL、PostgreSQL、SQLServer、Oracle、MongoDB 等数据库。\n定时任务：是可以 每隔一个时间段就执行一次。"},"title":"xxl-job"},"/devframe/spring/":{"data":{"":"基础概念 Spring使创建Java企业应用程序变得容易。 从Spring Framework 6.0开始，Spring需要Java 17+。 Spring支持广泛的应用场景。 Spring是开源的 引入的思想 OCP（开闭原则）：对扩展开放，对修改关闭\nDIP（依赖倒置原则）：降低程序的耦合度，方便修改，使用面向接口编程、面向对象编程\nIoC（控制反转思想）：反转\n在程序中不采用硬编码的方式去new对象、去维护对象之间的关系 引入Spring Spring是实现控制反转思想的一个框架 XML解析+工厂模式+反射机制\n可以new对象 可以维护对象之间的关系 实现IoC思想方式：依赖注入（dependency injection DI）完成bean管理\n依赖：两个对象之间的关系 注入：是一种方法，数据传递行为，实现两个对象之间的关系 使用Spring 引入spring相关jar包依赖\n需要sping的配置文件 *.xml\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--这两个就是bean，由spring上下文进行管理--\u003e \u003cbean id=\"userBean\" class=\"com.yushan.bean.User\"/\u003e \u003cbean id=\"userTestDaoBean\" class=\"com.yushan.dao.UserTestDao\"/\u003e \u003c/beans\u003e 获取Spring容器对象 应用上下文\nApplicationContext 通过当前类的根路径寻找配置文件：ClassPathXmlApplicationContext 根据文件系统寻找应用上下文：FileSystemXmlApplicationContext 获取bean对象\n创建bean对象的时机：默认创建应用上下文时 applicationContext.getBean(“id”) return new Object(); applicationContext.getBean(“id”,User.class) return new User(); 注意事项\nid不能重复 底层：是解析XML文件，获取结点信息，执行动作 存储结构：Map\u003cString,Object\u003e String : id Object : bean对象 "},"title":"Spring"},"/devframe/spring/aop/":{"data":{"":"代理模式 思想：找个中间商，在自己能干的事情基础上干自己不能干的事情，可以用来保护自己 进行代码易维护、进行功能增强 结构 目标对象 代理对象 目标对象和代理对象的公共接口或者继承 静态代理：has-a关系 关联关系 动态代理 JDK内置的java.lang.reflect.Proxy\t只能代理接口 cglib 底层采用继承，可以代理接口或者类 底层使用ASM字节码处理框架优化 javassist（千叶滋yyds） AOP(一个思想，面向切面编程) Aspect Oriented Programming 思想：切面是一个和业务逻辑毫无关系的东西；采用代理模式，把这些切面当做功能增强的东西单独提取出来，形成一个单独的组件，以横向交叉的方式应用到业务流程。 作用：代码复用、可读性高 交叉业务 Spring AOP 采用 JDK代理+cglib代理 术语 名称 意义 JoinPoint 连接点 切面可以切入的位置 CutPoint 切点 方法，被切的东西 Adivce 通知 具体增强的代码，切东西的工具 Aspect 切面 切点+通知 Weaving 织入 具体的动作 Target 目标对象 Proxy 代理对象 通知的类型和顺序 前置通知 环绕通知 后置通知 异常通知(当调用此通知，后续通知不再执行，若异常目标方法自己处理了，后续通知会继续执行) 返回通知 try{ ·前置通知 ·前环绕通知 ·目标方法 ·后环绕通知 ·后置通知 ·返回通知 }catch(Exception e){ ·异常通知 } 切点表达式 实例 public class Student { private String name; public Object exam(){ System."},"title":"AOP"},"/devframe/spring/ioc/":{"data":{"":"控制反转和依赖注入 Bean\n容器管理的对象被称为Bean 面向对象的封装特征，外部调用者无法直接操纵对象的属性，只能通过对象提供的方法去操纵 作用：对于某些场景设计方便，比如对应数据库的表、前端的数据属性、序列化存储 控制反转\n简单的说：反转的是对象属性的创建者，对象的属性不由自己来创建，而是把权力交出去，由其他东西在创建对象的时候再确定自己的属性。 对象仅通过构造参数、工厂方法的参数或在对象实例被构造或从工厂方法返回后在其上设置的属性来定义其依赖关系（即它们与之合作的其他对象）。 容器在创建 bean 时注入这些依赖关系。 从根本上说是Bean本身通过使用直接构建类或诸如服务定位模式的机制来控制其依赖关系的实例化或位置的逆过程。 依赖注入\n是实现控制反转的一种方法 依赖：代表的就是一个对象的属性 注入：就是在对象被创建的时候，给其属性赋值的行为 配置 在此，如果要实现依赖注入，就需要配置元数据(Metadata)，这一步的作用也就是自己指明某一个对象的属性要注入哪一个对象（有可能会多态）。\n配置方法的话\nxml：这大抵是最通用的方法，比如MyBatis也是这个，Servlet也是这个 注解：利用java的@interface，表明对象的属性，然后再实现一个基于包的类扫描器，再取出其注解 XML 结构\n\u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003cbean id=\"accountDao\" class=\"org.dao.AccountDao\"/\u003e \u003cbean id=\"itemDao\" class=\"org.dao.ItemDao\"/\u003e \u003cbean id=\"petStore\" class=\"org.service.PetStoreServiceImpl\"\u003e \u003cproperty name=\"accountDao\" ref=\"accountDao\"/\u003e \u003cproperty name=\"itemDao\" ref=\"itemDao\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 注解 组件的注解 @Component\n表示一个组件，在被扫描的时候，会注册到容器中，作为一个BeanDefinition 扫描 @ComponentScan(basePackages = “com.yushan”)\n当一个@Configuration类配置一个这个注解，会启动注解扫描，然后会把所有声明了@Component注解的类作为一个组件注册到容器中 xml\n\u003ccontext:component-scan base-package=\"com.yushan\"/\u003e @Configuration 这个注解，用来声明一个类作为一个配置元数据的地方，从这里可以获得BeanDefinition，而且这个类也是一个BeanDefinition。\n类级别的 表明该类是一个BeanDefinition的来源 可以处理Bean的依赖关系，而@Component不可以处理 @Bean 这个和xml配置的bean一样，用来表示一个方法来实例化配置一个新的对象，交给Spring容器管理\n方法级别的，方法的返回值就是一个BeanDefinition 默认bean的id就是方法名，当然还可以使用name属性配置Bean的名字 支持初始化、销毁的回调 依赖"},"title":"IoC"},"/devframe/springmvc/":{"data":{"":"MVC MVC是一种软件架构模式，Model-View-Controller。作为一个服务端，要接收若干请求，然后进行相应处理，还要返还给客户端数据，所以这一套流程，如果都糅合在一个代码块里，对于系统的维护是非常复杂的。所以采用MVC模式\nModel：模型，代表着业务逻辑和数据部分，如客户端发送的数据，服务端处理好的数据 View：视图，代表着和客户端展示结果的部分，比如可以返回一个页面 Controller：控制，代表着和客户端交互的部分，接收客户端的输入，处理模型数据，返回试图 Spring Web MVC 流程 就是Servlet的封装，建立在Servlet API上的原始Web框架 大致的流程就是\n由一个调度器接收请求uri 通过map\u003curi,handler\u003e，查找获得一个处理器 再将这个处理器交给执行器 执行器执行的结果返回给调度器 调度器将结果给视图部分，返回给调度器 调度器返回给客户端 网上具体的\n用户发送出请求被前端控制器DispatcherServlet拦截进行处理。 DispatcherServlet收到请求调用HandlerMapping（处理器映射器）。 HandlerMapping找到具体的处理器(查找xml配置或注解配置)，生成处理器对象及处理器拦截器(如果有，也就是执行器链)，再一起返回给DispatcherServlet。 DispatcherServlet调用HandlerAdapter（处理器适配器）。 HandlerAdapter经过适配调用具体的处理器（Handler/Controller）。 Controller执行完成返回ModelAndView对象。 HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover（视图解析器）。 ViewReslover解析ModelAndView后返回具体View（视图）给DispatcherServlet。 DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应View给用户。 "},"title":"Spring MVC"},"/essay/":{"data":{"":"小笔记"},"title":"_index"},"/essay/bash/":{"data":{"":"概念 简单的概念就是linux是一个内核，然后需要一个shell来和linux内核打交道，bash就是shell的一种，其他的还有ksh,zsh,sh，和用户打交道的就是终端，它来接收用户输入的信息，传递到使用的bash里，终端比如konsole,zutty,terminator，很多……\n终端：人机接口的工具，输入shell命令的工具，如konsole，zutty bash：是shell的一种类型，其他的还有zsh ，sh ，dash shell：是“壳”的意思，是在计算机内核之上套了一层，用来接收用户指令的界面 shell 分类：\n图形界面shell：如linux的ghome， kde， 命令式shell：如sh/bash/zsh/ksh 交互式和非交互式 交互式shell：是与用户交互的，等待用户输入的命令的shell， 非交互式shell：是以脚本运行的，比如编写一个start.sh，就可以用bash工具运行它 登录式和非登录式 这个是根据两种shell所读取的配置文件不同而区分的 登录式shell：当第一次登录linux系统时，分配的shell就是登录shell，还有在终端使用su命令登录后，只能使用logout命令退出的就是登录式shell，比如使用虚拟机时没有安装GUI，那个使用root提示的就是登录shell，还有ssh远程连接时，那个也是登录shell，读取文件： /etc/profile /etc/profile.d/*.sh ~/.bash_profile ~/.bashrc /etc/bashrc 非登录式shell：和用户无关的shell，比如在linux系统里，使用终端打开的shell，那是非登录的，它读取的文件是不一样的。 ~/.bashrc /etc/bashrc /etc/profile.d/*.sh 判断 要进行测试的话，在每个文件内添加echo命令就可 判断是哪个shell，-bash是登录式shell 使用 "},"title":"终端"},"/essay/git/":{"data":{"":"简介 需求：若是编辑一个文件时，想去保留每次修改的版本，以便当想去回滚版本的时候，也就是这次修改的不行，想要去使用以前的版本，所以，最常见的就是每次修改都另存为一个新文件，这种方法简单，但是繁琐\n发展历史\n本地化版本控制系统 集中式版本控制系统：多个主机使用一个中央服务器的版本数据库，容易单点故障，出现故障的时候，多个主机无法工作 分布式版本控制系统 Git （分布式版本控制系统）\nGit由Linus Torvalds开发，用于在linux系统项目中使用。Git是建立一个仓库，这个仓库可以存储好多文件并进行管理，而且是直接存储文件快照，也就是每个主机都有文件的备份，可以解决集中式版本控制系统的单点故障问题。\n也就是说，当文件被更改的时候，新的版本记录的是最新的全量文件，而不是记录修改的差异，而且没有修改的文件则是链接，链接到上个版本文件。\n仓库中文件状态 仓库中有很多文件，每种文件都有不同的状态，有新建的、修改的、完成的，在Git中，可以理解为仓库中有箱子将这些不同状态的文件区分出来，需要人工手动地将文件移动到其他箱子，从而改变文件的状态。\n状态：\n已修改：是指目前文件内容和仓库记录该文件的内容不一样 已暂存：是指记录了文件可以更新了，以便更新到仓库中记录的最新内容 已提交：是指文件在仓库中已经是最新内容，安全的保存成功 总的来分，所有的文件都是两个状态未跟踪和已跟踪，未跟踪的文件是不属于仓库管理的文件，比如你新建一个文件的时候，这个文件就属于未跟踪状态，只有在使用命令git add将文件移动到暂存区，才会变成已跟踪状态。已跟踪状态则是已经提交和已经修改，已提交的文件是安全的保存在仓库中，已修改的文件是修改了，但是还没有提交（commit）到仓库中。\n所以，根据文件的状态可以将仓库划分三个区域，工作区、暂存区、git仓库；\n工作区：是Git仓库压缩出来的一部分，以便用户可以修改这些文件 暂存区：是一个文件，记录需要提交的修改后的文件 Git仓库：是最终的数据库，保存的都是最新的内容 安装和配置 官网：Git下载\n配置\n配置用户名和邮箱，因为在提交代码的时候，需要记录提交者的信息 git config --global user.name \"yushan song\" git config --global user.email \"yushan.song@gmail.com\" --global，这个是全局配置，如果只对当前仓库生效，则不需要加\n基础 仓库：将整个文件夹变为一个仓库进行管理文件\n本地仓库：如果仅仅个人使用，利用Git的优点管理自己的文件，可以将文件夹变为一个仓库，然后自己进行操作 git init 远程仓库：一般用于多人协作开发一个工程，或者自己推送到软件项目托管平台，以供别人访问及使用 git push origin master git clone \u003curl\u003e 本地仓库内文件操作：\n状态：\ngit status 可以查看当前仓库的文件状态，比如你修改了什么，新增了什么，删除了什么 添加至暂存区(stage)：\ngit add \u003cfile\u003e/\u003cpath\u003e 将未跟踪的文件进行跟踪，将已跟踪且修改的文件添加到暂存区 将文件添加到暂存区，精确的说：“是将文件添加到下一个版本中”，每次add都是创建一个新版本，但是暂存区中只有一个版本，所以每次add都是覆盖之前的版本。 比如，当出现Untracked files这个信息，就表示有未跟踪文件（新增的），就可以使用这个命令将其添加到暂存区，交由git管理。 提交到仓库：\ngit commit -m \"message\" 将暂存区的文件提交到仓库中，提交之后，这个文件就变成了已提交状态，可以理解为这个文件是安全的保存在仓库中，可以提交到远程仓库中。 分支 "},"title":"Git"},"/essay/java-standard/":{"data":{"":"规范 通过学习阿里巴巴开源的Java开发规范，学习到一些编程规范，通过编程规范，让开发小组提高开发效率，减少bug，提高代码质量。\n名称 类名大驼峰：UserInfo 变量名小驼峰：user 常量名全大写：USER_INFO_DICT 布尔型不要写is：isDeleted -\u003e deleted 对于MVC中\nService层命名：UserInfoService，且在应用中暴露的都是Service接口 Service实现类命名：UserInfoServiceImpl，以impl结尾 Service/DAO 层方法命名规约\n获取单个对象的方法用 get 做前缀。 获取多个对象的方法用 list 做前缀。 获取统计值的方法用 count 做前缀。 插入的方法用 save/insert 做前缀。 删除的方法用 remove/delete 做前缀。 修改的方法用 update 做前缀。 领域模型命名规约\n数据对象：xxxDO，xxx 即为数据表名。 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。 展示对象：xxxVO，xxx 一般为网页名称。 POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 "},"title":"Java开发规范"},"/essay/setup/":{"data":{"":"JDK linux下：\n从Oracle官网下载jdk 上传至指定目录中，如/usr/local 解压压缩包tar -zxvf jdk-8u202-linux-x64.tar.gz 配置环境变量vim /etc/profile export JAVA_HOME=/usr/local/jdk1.8.0_202 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib/dt.jar:${JAVA_HOME}/lib/tools.jar export PATH=${JAVA_HOME}/bin:$PATH 执行source /etc/profile 检查JDK是否安装成功java -version Maven linux下：\n从官网Maven下载压缩包 上传到指定目录中，如/usr/local 解压压缩包tar -zxvf maven-3.6.3-bin.tar.gz 配置环境变量vim /etc/profile export MAVEN_HOME=/usr/local/maven-3.6.3 export PATH=${MAVEN_HOME}/bin:$PATH 配置settings.xml \u003csettings\u003e \u003c!-- 修改本地仓库地址 --\u003e \u003clocalRepository\u003e/usr/local/maven-repository\u003c/localRepository\u003e \u003cmirrors\u003e \u003c!-- 配置阿里云仓库 --\u003e \u003cmirror\u003e \u003cid\u003ealiyunmaven\u003c/id\u003e \u003cmirrorOf\u003e*\u003c/mirrorOf\u003e \u003cname\u003ealiyun nexus\u003c/name\u003e \u003curl\u003ehttps://maven.aliyun.com/repository/public\u003c/url\u003e \u003c/mirror\u003e \u003c/mirrors\u003e \u003c/settings\u003e 执行source /etc/profile 检查Maven是否安装成功mvn -v "},"title":"安装与配置"},"/essay/vim/":{"data":{"":"伟人Bram Moolenaar （1961—2023.8.3），编辑器之神Vim之父\n1961年——出生在荷兰莱斯镇 1985年——代尔夫特理工大学毕业，获得电气工程学士学位 1988年——开发Vim 简介 Vim开源、免费的文本编辑器 Vim初始是根据Vi来编写的 初始版本为“Vi IMitation”，1992年，在版本1.22中改名为“Vi IMproved” 优点\npersistent, multi-level undo tree 持久的、多层次的undo树 extensive plugin system 广泛的插件系统 support for hundreds of programming languages and file formats 支持数百种编程语言和文件格式 powerful search and replace 强大的搜索和替换能力 integrates with many tools 集成了许多工具 Vim官方网站vim.org\n善举ICCF（International Child Care Fund）国际儿童保育基金，是一个慈善组织。Bram Moolenaar还通过Vim项目鼓励开发者对乌干达的艾滋孤儿捐赠。将网站的收入和赞助全部捐赠给这个组织，帮助乌干达的孤儿。\n结构命令模式 进入vim时，就是命令模式 可以移动光标 可以删除、复制、粘贴文本 可以撤销、反撤销 输入模式 在命令模式下按 i或者a或者o即可进入该模式 在该模式中就可以输入文本了 按Esc就可以回到命令模式 命令行模式 在命令模式下按 :即可进入该模式 在模式中，有大量的命令可以输入 比如常用的保存w、退出q 操作 全文复制 思路 第一行为gg,最后一行为G,复制为yy，结合起来，在可视令模式下输入 ggyG 配置 可以使用Vbundle进行插件配置 主要是vimrc文件，可以在~/."},"title":"Vim"},"/essay/windows/":{"data":{"":"端口和进程 查看端口的占用和进程，并且kill进程\nnetstat -ano | findstr 6379 tasklist | findstr redis-server taskkill /F /PID 1234 taskkill /F /IM redis-server.exe "},"title":"windows下操作"},"/java/basic/basicknowledge/":{"data":{"":"面向对象和面向过程 面向对象 OOP：\n将现实世界的实体所拥有的状态和行为封装成一个类，以面向这个实体的方式进行程序构建，在实体的主观感受操作。 通过对象来描述现实世界中的实体以及它们之间的交互关系。 状态-\u003e属性 行为-\u003e方法 面向过程 PP：\n主要强调的是程序执行的流程，以函数和数据结构为基础进行编程 程序量比较大时程序难以维护 面向对象三大特性 继承 如果多个实体有共同的状态和行为，可以将这些共同的状态和行为提取出来，然后形成一个单独的实体，那些实体可以继承这个新的实体，达到复用的目的，而且容易维护。 阻止继承：类使用final关键字声明，之后这个类不能被继承，然后方法也自动是final方法。 继承：是实现了类之间的 is-a 关系 封装 信息隐藏，形式上是将对象的数据和行为组合在一个类中，并且对使用者隐藏具体的实现细节 重要：程序只能通过对象的方法才能和对象的数据进行交互，使用者是看不见数据的 多态 指一个对象有多种状态，主要分为编译时多态，运行时多态 编译时多态：方法的重载 运行时多态：程序中定义的对象引用所指向的具体类型在运行期间才确定 对象的方法调用：\n确定对象的实际类型 匹配方法 采用动态绑定/静态绑定 静态绑定：构造器、private、static和final方法，这些方法编译器能够明确，称为静态绑定 动态绑定：除了以上，必须采用动态绑定， 虚拟机必须调用与 a对象引用的实际类型对应的方法，如果在实际类型没有找到，必须在超类中调用，但是这个过程慢，所以虚拟机生成方法表，列出所有方法的签名和要调用的实际方法。 调用方法，从方法表（虚拟机加载一个类时创建）中 如下： Manager 继承 Employee 当一个 manager 对象调用getName方法时，直接查表就知道该调用哪个方法\npublic class Employee{ private String name; private int salary; public String getName(){ return name; } public String getSalary(){ return salary; } } 方法表大概为： Employee getName\t-\u003e Employee.getName() getSalary -\u003e Employee."},"title":"概念"},"/java/basic/collection/":{"data":{"":"集合是存放对象的容器，用来存放对象的引用 线程安全的集合类\nVector：老版本的，加了一个synchronized HashTable：老版本的 ，加了一个synchronized ConcurrentHashMap：并发HashMap，以前是锁住一个段，现在是锁住一个桶 Set 在java的大部分实现类，都是采用了Map，value都是一个final Object对象，key算是自己添加的值，也就是集合的值 HashSet 集，存储的元素不相等的 无序，添加元素的顺序和存储的顺序是不一样的， 也可以保证有序，如LinkedHashSet，构建时传入一个dummy（true）作为第三个参数，会创建一个（LinkedHashMap） 底层直接使用HashMap存储，value是一个固定的对象，key的hash判断不相等是不添加的，相等时也就是默认的替换老值。 扩容机制都是采用HashMap的 是如何保证不重复的？\n是直接利用了HashMap的putVal方法 如果两个key相同，这直接替换掉了 LinkedHashSet 有序的集，直接继承HashSet 创建时dummy设为true，后续使用包级别的构造方法创建LinkedHashMap TreeSet 底层使用了TreeMap 采用红黑树，保证了元素的有序 List 是一个列表 就是数据结构的线性结构 ArrayList 存储数据还是 Object[]数组，返回元素时，是进行泛型类型的转换，也就是Object-\u003e变为 E 支持基于下标的快速访问 插入O(1)，删除O(N) 容量机制\n默认为 10个元素 扩容数组长度：1.5倍，new=old*1.5 size：数组实际元素的个数，也就是实际存在的元素 Array 是java用来存储相同类型元素，必须在使用前指定大小，通过索引机制访问元素 所以不可以扩缩容 是一种引用数据类型 如下，names、ages变量，它们是一种引用数据变量，当使用new关键字时，会在堆中创建连续的内存空间（每一个内存空间的大小，在类加载阶段就能确定），在虚拟机栈中会存储引用数据变量的具体指向地址 String[] names=new String[10]; int[] ages=new int[10]; User[] users=new User[10]; LinkedList 底层是 Node节点，使用链表的形式存储元素 默认是插入尾部 区别\n线程都不安全 ArrayList查询速度快 LinkedList插入，删除速度快 Queue 先进先出的特性 判断队满：head=(tail+1)%size 判断队空：head=tail HashMap size：是key-value的个数 length：是Node数组的长度 初始容量：16 最大容量：2的30次方 默认加载因子：0."},"title":"集合"},"/java/jvm/class/":{"data":{"":"字节码字节码即java跨平台的重要支撑点，它是一个.class文件，通过一个编译器生成的。平常的.java文件，还有Kotlin的.kt文件，它们如果都遵循编译规则，生成字节码文件，都是可以运行在JVM上的。 字节码的生成：在java中，它可以通过javac编译器生成，javac是一个全量式编译。 javac的使用\njavac Main.java javac -d /opt Main.java ，文件编译到/opt目录下面，并且生成包结构，即package语法。 Class文件 魔数：每个字节码文件的前4个字节都是固定的魔数0xCAFEBABE，用于标识这是一个Java字节码文件。 版本信息：紧接着魔数的是版本信息，包括次版本号和主版本号，表示编译该字节码的Java编译器版本。 常量池：常量池是字节码文件中资源的集合，包括文字字符串、类或接口名、字段名和其他常量。 访问标志：这部分包含类的访问权限等信息。 此类索引、父类索引和接口索引集合：这些索引指向常量池中相应的类和接口。 字段表：包含了类中声明的变量信息。 方法表：包含了类中定义的方法信息。 属性表：包含了类的其他属性信息，如注解 类加载为什么？\n速度快、安全性\n面向对象，要通过类文件创建实例对象，在编写代码时，会使用到各种各样的类，多种类之间又会互联关联、依赖。 jvm要读取class文件的信息，创建对应的实例对象，如果类文件放在磁盘上，jvm读取会产生磁盘I/O，性能比较低，再加上class文件可能会被修改，安全性得不到保证。 所以，在需要时，将类文件加载到虚拟机的内存中，可以更快的得到类信息，而且安全性可以得到保障。 步骤：\n加载 验证 准备 解析 初始化 加载 通过类的全限定名（包名+类名），找到.class文件，然后将类的信息转为字节流 将字节流加载到内存的方法区，映射为jvm识别的数据结构 在内存中生成一个代表该类的 java.lang.Class 对象，作为方法区这些数据的访问入口 连接 验证 验证是连接阶段的第一步，这一阶段的目的是确保 Class 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。\n字节码文件格式验证：验证文件是否能够正确的加载到方法区中， 元数据验证：进行语义分析，确保类的元数据（如类名、父类、接口等）正确 字节码验证：针对程序，验证程序的语义是否符合逻辑 符号引用验证：验证符号引用指向方法区中的对象是否存在 准备 该阶段是为类变量（static变量）分配内存，并设置初始值\n这个阶段仅仅分配类变量 分配到 方法区 jdk1.7以前，是在方法区中（永久代），内存还是jvm内存 jdk1.7及以后，是在方法区中（元空间），但是此时将字符串常量池、类变量都移动到堆区中了，类变量跟随加载阶段创建的Class对象，放在堆中 类型 默认值 int 0 long 0L short 0 char ‘\\u0000’ byte 0 boolean flase float 0.0f double 0."},"title":"Class文件"},"/java/jvm/memory-region/":{"data":{"":"Java内存区域 内存区域图 jdk1.8以前：\njdk1.8及以后：\n对于线程和进程的职责：\n线程独有\n程序计数器、本地方法栈、虚拟机栈 线程共享\n堆区、元空间 程序计数器 在计组中，PC为控制器里面的一部分，它记录的是下一个指令所在的地址，用于指令跳转 在java中\n记录的是当前线程正在执行的字节码的指令地址，也就是行号 因为在多线程的情况下，每一个线程都会有自己的程序计数器，然后在线程切换的时候，用于恢复现场，继续执行 程序计数器是一个很小的内存空间，它仅仅记录的是一个指针 线程私有的，生命周期跟随线程 是唯一一个没有OOME的区域 虚拟机栈 栈是一个先进后出的数据结构，这就符合方法的递归调用的应用，一个方法调用另一个方法，这就符合栈的特性 在java中，虚拟机栈应用在存储方法调用使的局部变量、操作数等信息 异常\nStackOverflowError：方法调用太深，虚拟机栈太深 OutOfMemoryError：虚拟机栈申请不到内存 如图：\n局部变量表 存储方法的形参、方法内的局部变量，每一个局部变量有一个索引值，用于快速访问 局部变量必须初始化才能使用 操作栈 可以回想一下（2-3）*4，这个表达式的算法该怎么设计，利用两个栈，然后再利用操作符号的优先级，进行入栈、出栈的操作。还有前缀表达式、后缀表达式。 在java中\n是字节码指令执行过程的临时存储 由于局部变量表存储的是变量，而操作栈就可以动态的处理变量，进行一个中转站的使用 动态链接 回想多态特性的运行时多态，方法的具体调用要到运行期间也能确定 这个动态链接存储的是量池里的该方法的引用，支持调用过程中的动态链接。 方法返回地址 要保证每一个方法执行完之后应该返回到正确的位置，接着上一个方法的执行。 此时的操作就是弹出当前栈顶的栈帧 本地方法栈 和虚拟机栈类似，不过本地方法栈记录的是native方法的信息 native方法：\n用于在jvm上调用操作系统层面的方法，由c++/c语言编写的 堆区（heap） 在该区域中，主要用来存放对象实例，也是垃圾收集器的主要工作区域。\n分代回收算法，越老的区，垃圾回收频率越低（使用次数晋升）堆区划分：\n新生代 老年代 逃逸分析\n如果某些方法中的对象引用没有被返回（return）或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存 字符串常量池 因为在程序中字符串的使用占大量，所以单独开辟一个区域用于快速访问内存中字符串变量的信息。 字符串常量池可以看作是一个map，其中value用于映射堆区中的地址 它的实现是一个stringtable 历史\njdk1.7以前，是在永久代中 jdk1.7及以后，移动到堆区中了 为什么：在永久代中垃圾回收效率低，没有堆区GC效率高 方法区 方法区是一个概念，它是一个逻辑区域，在运行时，需要读取各种类的信息，如字段信息、方法信息、常量、静态变量等等，方法区就是把这些信息划分出来的一个单独区域。 永久代、元空间\n它俩是方法区的实现方式 永久代是在jvm运行时内存区域，然后容易OOM 元空间是在本地内存上的实现 运行时常量池 用来存储class文件中的各种字面量和符号引用 它相当于是class文件常量池在内存中的映射 字面量：\n是在源代码直接出现的值，可以是数字、字符 如 int a=12; String s=“abc”; class文件常量池"},"title":"Java 内存区域"},"/java/jvm/object/":{"data":{"":"对象 对象，在java中有很多很多对象，在代码中，此对象调用另一个对象，这个对象又执行了它的方法。这时候就要了解，此对象长什么样，以及它又如何调用方法，使用属性的。 对象的创建流程 类加载检查 对象是类的实例，类是对象的模板。 创建对象，首先要检查对应的类是否加载完成并且初始化。 如果没有，就要进行类的加载过程。 分配内存空间 在类加载检查通过后，就可以分配内存空间了 空间的大小由类加载完成后确定 分配方式：指针碰撞、空闲列表 初始化零值 在类中，实例属性可以不初始化，在创建对象后就会有默认值可以使用，就是这一步的原因 这一步进行初始化对象布局里的实例数据，不包括对象头 设置对象头 由虚拟机设置该对象的信息。 如对象的哈希码、GC状态、锁信息、分代年龄、线程ID等重要信息 执行init方法 当创建对象是通过构造器的话，会执行这一步骤，用来进行自定义的初始化工作 分配空间方式及问题 采用那种方式取决于 Java 堆是否规整，而 Java 堆是否规整又取决于采用的垃圾收集器是否带有压缩整理功能\n指针碰撞：\n适用于堆规整，将已使用的内存和未使用的内存分成两部分，当一个对象需要分配空间时，通过它的大小，将指针移动到未使用的内存那边 使用该分配方式的 GC 收集器：Serial, ParNew 空闲列表\n适用于堆不规整，此时就要维护一个列表，记录内存的空间状态 通过对象的大小，找一块区域分配即可 使用该分配方式的 GC 收集器：CMS 内存碎片的问题，是有垃圾收集器的算法处理 问题\n一个类可以有多个实例，但是当一个实例遇见多个线程同时创建，会遇见并发问题 解决\nCAS：比较和交换，这是一种乐观锁的方法，假设当前没有问题，等处理完毕，比较一下，不相等了，就重试了 TLAB：（Thread Local Allocation Buffer），是线程专有的一块区域，它使线程不共享公共区域，减少竞争。 它是在堆区中Eden区域的一小部分，适合在线程上分配较小的对象，当遇见较大的对象，空间不够时，还会在堆区上分配对象空间，继续采用CAS操作分配。 对象的内存布局 对象头：第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等）；另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 实例数据：对象的数据，包括父类的属性、本身的属性 对齐填充：jvm要求对象的大小是8的倍数，当对象的实例数据不够8的倍数，就需要填充占位符对齐了 对象头 Markword\n记录对象的信息，如哈希值、线程ID、分代年龄、锁的状态 在32位系统占4字节，在64位系统中占8字节 32位jvm：\n无锁时（正常对象）：hashcode占据 25bit，分代年龄4bit，偏向锁标识 1bit，锁的状态 2bit 偏向锁对象：线程ID 23bit，epoch 2bit，分代年龄4bit，偏向锁标识 1bit，锁的状态 2bit。 此时当对象持有对象的偏向锁时，无需使用原子操作 CMS（concurrent mark sweep）：是一个垃圾回收器 轻量级锁状态：前30bit，指向栈中锁记录的指针 重量级锁状态：锁膨胀，前30bit，指向对象的监视器 64位jvm"},"title":"对象"},"/java/thread/basic/":{"data":{"":"进程/线程cpu:\n中央处理器 是一个特殊的处理器，负责解析和执行计算机程序的指令 架构： SMP：对称多处理器，多个cpu相同对待，共享内存、总线 AMP：异步多处理器，每个cpu有自己的内存、总线资源，通信采用共享内存 多核：\n将cpu划分为多个core，形成一个个独立单元，可以独立执行任务 所以并行执行进程/线程是可以的 intel 4核8线程：这个8线程是指超线程，将每个核心划分两个逻辑核心，防止资源的浪费，4核就是cpu具体的核心数了。 内核：\n是指在一个cpu处理器中，划分出来的一部分，主要功能和其他部分不同 它负责管理软件部件（进程） 虚拟内存：\n它是假的“内存”，让程序认为他自己所占用的内存空间是连续的，实际上是有可能不连续的。 它和物理内存的映射关系，将采用页表的形式记录下来，还有快表这个缓存。 它通过文件的形式记录程序的数据和地址，在所需要的数据不再内存中时，才加载到物理内存中。 进程 用来支撑程序运行的东西，用来分配和管理程序所要使用的资源，当然也是计算机分配资源的基本单位 由操作系统进行管理进程 线程 是更小的单位了，在进程运行时可以产生多个线程，每个线程可以处理自己的资源，并且还会共享进程的内存空间和资源量。 CPU进行使用的基本单位 用户线程/内核线程 用户线程：由用户空间程序管理的线程，创建和切换成本低，不可以利用多核 内核线程：由内核管理的线程，创建和切换成本高，可以利用多核 线程模型 用户线程和内核线程之间的关联方式、调度方式，用户线程的创建、操作都会映射到内核线程上，处理多线程的并发执行\n一对一：一个内核线程对应一个用户线程 一对多：一个内核线程对应多个用户线程 多对多：多个内核线程对应多个用户线程 为什么会有呢？\n时间片切换：在资源方面，出现竞争关系，将采用时间片切换算法，将每一个进程分配一定的时间，比如50ms，时间一到，将保存该进程运行的状态，如内存里的值、寄存器状态，这些关于自己的状态，被称为上下文。这些操作需要大量的时间，进程的消费比较大，进程有自己的虚拟地址空间，然而线程就可以共享进程的空间，在切换时消耗小。 虚拟内存：进程在运行初，会申请内存；虚拟内存和物理内存存在映射，也就是页表，切换时需要保存页表，还有其他的快表（TLB、缓存），切换会被清空 任务并发：在一个程序运行时，当有多个独立任务时，采用多个线程可以快速的完成，再加上会共享进程的内存空间，而且线程不会切换上下文，很快。 并发/并行？并发（Concurrent）：\n是指在一个时间段内，多个线程争抢一个cpu资源，然后无法并行操作，cpu只能进行时间片切换，会出现线程的挂起等操作，这中现象就是并发。 并行（Parallel）：\n是指在某一时刻（同时），多个任务一起执行 在cpu的核心数足够的时候，多个进程可以很好的运行在多个核心上，不出现竞争关系，这称为并行。 Java层面多线程 为什么要有多线程？\n一个线程处理任务慢，采用多个线程利用多个核心运行，在不出现竞争资源的时候，执行速度杠杠的。 带来的问题：\n共享进程的内存空间，若是出现竞争资源的关系，需要额外的处理 死锁问题：两个线程都“吃着碗里，看着锅里” 内存泄漏：线程创建的对象没有释放 在单核cpu运行多线程呢？\n这要取决与线程的任务类型，比如cpu密集型，它所消费cpu是比较久的，这时候要采用多线程效率就低了。 还有IO密集型，线程的任务主要是完成IO操作，所以线程可以利用完成IO的时间，利用cpu 线程状态 线程由进程创建后，会有一定的生命周期，在java中，有以下状态：\nNEW：新建状态，是new了之后，没有后续动作的时候 RUNNABLE：运行状态，是start后，正在运行的时候 BLOCKED：阻塞状态，被动的阻塞了，比如竞争资源失败了 WAITING：等待状态，调用了wait/join之后的状态，这时候必须需要别的线程来呼叫，叫醒这个线程，然后进入运行状态。 TIME_WAITING：超时等待状态，调用了sleep之后的状态，需要别人来叫醒，或者自然醒。 TERMINATED：死亡状态，终止状态，run方法结束之后的状态。 阻塞和等待 阻塞状态：\n这是线程去竞争临界区的锁失败后的状态 之后，还可以去竞争，继续运行 等待状态：\n这是线程主动等待，释放锁，也就代表释放占用的资源了。 这都是获取到锁之后，才能去操作的。 线程死锁 死锁：\n多个线程都处于阻塞状态，程序无法停止；如多个线程都在竞争某些资源，但是这些资源都被互相占用着，都不释放，所以线程都处于阻塞状态。 条件："},"title":"基础概念"},"/java/thread/pool/":{"data":{"":"线程池 池化技术，对于线程来说，在一个池中存放许多线程对象，当来一个任务的时候，不需要创建新的线程对象，而是直接从池中拿一个线程对象来使用，进行处理任务 好处：\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 Executor接口 用来在未来某个时间执行Runnable的任务 执行程序可以在调用者的线程中立即运行已提交的任务，当然也可以在execute方法中新开一个线程执行run方法 public class ExecutorOne implements Executor { @Override public void execute(Runnable command) { command.run(); } public static void main(String[] args) { ExecutorOne exec = new ExecutorOne(); exec.execute(()-\u003e System.out.println(\"hello,world！\")); } } Callable @FunctionalInterface public interface Callable\u003cV\u003e { //计算结果，无法计算抛出异常 V call() throws Exception; } 和Runnable类似，但Runnable无法返回结果 该接口提供了一个call的动作，所以任何实现该接口的类，都会有这一个动作，此时可以结合其他类，利用实现Callable接口的类做一些功能，如果结合线程，就可以不占用主线程做一些异步任务，并且可以获取计算的结果，挺好！ Future public interface Future\u003cV\u003e { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } 代表的是异步计算的结果，允许程序员对异步执行的任务进行控制和获取结果 接口的功能主要关注的是任务的结果，和Runnable不同，Runnable只有一个run方法，只是可以利用线程完成一系列不关心结果的任务 ExecutorService public interface ExecutorService extends Executor { void shutdown(); List\u003cRunnable\u003e shutdownNow(); boolean isShutdown(); boolean isTerminated(); //执行一个任务 \u003cT\u003e Future\u003cT\u003e submit(Callable\u003cT\u003e task); \u003cT\u003e Future\u003cT\u003e submit(Runnable task, T result); Future\u003c?"},"title":"线程池"},"/mysql/basic/":{"data":{"":"数据类型 char和varchar\nchar：定长字符串，当实际的字符串长度小于定义的长度，则会在尾部填充空格，检索时会去掉空格 varchar：不定长字符串，使用额外的字节来记录实际的字符串长度 decimal和float、double\ndecimal：定点数，可以表示精确的小数 float、double：浮点数，可以表示近似的小数 null\n是不确定的值 视为相等的情况：分组group by 、排序 order by 、去重distinct 视为不相等的情况：比较 = 聚合函数中 sum avg min max 忽略null值 count(*)会记录null count(属性名)会忽略null ''：这个是空字符串，长度为0，没有值 码 码：能够唯一标识一个实体的属性 候选码：属性、属性组能够唯一标识一个实体，而其子集不能标识 主码：从候选码中选出来的一个 外码：一个关系的属性是另一个关系的主码 主属性、非主属性：是否是候选码的属性里 e-r图：实体联系图，实体、属性和联系 函数依赖 针对的是 非主属性和主键的主属性之间的依赖关系，也就是由什么来确定什么 如范式关系 R(学号，姓名，性别，班级，班主任，课程号，课程名，学时数，成绩) 完全函数依赖：（学号，课程号）-\u003e成绩，才能确定一门课的成绩 部分函数依赖：（学号，课程号）-\u003e姓名、性别、班级，这几个只依赖于主属性 学号 传递函数依赖：不能直接确定关系，如 班级和学号 范式 1NF(第一范式)：属性不可再分。 2NF(第二范式)：1NF 的基础之上，消除了非主属性对于码的部分函数依赖，非主属性都完全依赖于主键的主属性。 3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。 连接 on、where的区别：on是在生成连接临时表的时候使用，where是在临时表生成之后再进行筛选 1:1 1:n m:n "},"title":"基础知识"},"/mysql/engines/":{"data":{"":"存储引擎 一些命令：\nshow engines; select version(); select variables like ‘%storage_engine%’ 存储引擎是什么？ 数据需要存储，但按照什么方式进行存储，这是多种多样的。这些方式就是各种各样的存储引擎，它可以定义自己的方式，进行存储数据、检索数据、管理数据。MySQL提供了一个存储引擎的抽象概念，市面上有各种各样的存储引擎，innodb、myisam。 存储引擎是作用在表上的，每个表的存储引擎可以不相同。 区别： 索引：InnoDB和MyISAM都支持索引，都采用B+树作为索引的数据结构。但是 InnoDB 索引文件和数据文件在一起的，每个节点都存储。 MyISAM 是分开的，非聚簇索引，节点指向数据文件的位置。 行锁：InnoDB支持行锁，MyISAM支持表锁。粒度不一样。 事务：InnoDB支持事务，提供隔离级别；MyISAM不支持事务。 外键：InnoDB支持外键；MyISAM不支持。但是当更新操作时，外键会触发级联更新，性能会慢，而且可能会出错。 InnoDB是以页为单位存储数据的 "},"title":"存储引擎"},"/mysql/index/":{"data":{"":"数据结构类型 Hash：查找速度O(1)，但是会出现Hash冲突，解决冲突可以使用拉链法。但是查询一个范围时，需要多次hash映射，才能得到全部数据。O(N)\n二叉搜索树 ：理想速度O(logN)。但是非递减数据会退化成链表。\n平衡二叉树 ：解决二叉搜索树的问题。各种操作最坏情况复杂度O(logN)。但是：\n元素多，高度还是会高 维护平衡，代价高，通过各种旋转，O(logN)。 每个节点存储的数据少，也就是节点上每次加载的数据太少，即便找到了数据，也需要多次磁盘IO去取数据。 可以范围查询，中序遍历就是有序的数据。 因为数据量比较大，一次性不一定能把数据全部加载到内存中。 红黑树 ：解决平衡二叉树的维护平衡的问题。通过颜色的改变，可以在O(1)的复杂度下维护平衡。但是，缺点还是平衡二叉树大差不差。\nB树 每个节点都存储数据,每一个节点都会存储指针 概念\n阶：一个数的最大子节点的个数，同时也控制每一个节点的键的数量的上下限 根节点，中间节点：非根、非叶子结点，叶子结点 键值对：是每个节点所存储的数据，每个节点有一个最小键、一个最大键，键的值是按照非递减的规则排序 重点 B数的结构控制，假设B树的阶数为 m\n根结点至少有两个子女。 中间节点：k-1个键和k个孩子(指针)，其中k的范围[m/2,m] 叶子节点：k-1个元素，其中k的范围[m/2,m] 叶子节点都在一层 通过这些规则，B树可以达到自平衡 插入：键的非递减顺序、超过范围进行父节点的选举 删除：不足范围进行合并\nB+树 只有叶子结点存储完整数据，并且每个叶子节点可以链接 m阶的B+树每个节点的键的范围：[m/2-1,m-1]；向上取整\n叶子节点中存储全部的数据 每个叶子节点采用双向链表进行关联 中间节点：一个键对应一个子节点，共k个键； 采用B树、B+树在mysql的好处 速度：多路索引，树的高度能够降低，然后一次磁盘IO可以取出更多的数据 顺序查询：B+树，叶子节点采用双向链表关联，可以进行范围查询 如果需要高效的查询和插入操作，那么红黑树可能是更好的选择； 如果要进行大量的数据读写操作，那么B+树可能更适合。 聚簇索引、非聚簇索引 聚簇索引\n叶子结点的data包含记录的全部数据记录 整条树是根据主索引建立，这就是为什么数据库表中只能有一个primary key 其他是辅助索引，在根据辅助索引查询时，需要先辅助索引的data确定其主索引，再走主索引树 非聚簇索引\n叶子结点的data包含指向记录数据的指针 回表查询：当查询结果正是需要的索引关键字，不需要回表取数据 类型 辅助索引 也叫二级索引，存储的是主索引的值 唯一索引，普通索引，前缀索引，全文索引都是的 sql语句\nalter table table_name add index/fulltext index/unique index column(index_name); --前缀索引 create table table_name( index(column_name(length)) ); create index index_name on table_name( column_name(length) ); 覆盖索引 在简单查询的时候，解决回表查询。 意思就是：如果查询的数据，正是索引关键字的属性，就直接返回，不用通过主键查询一次了"},"title":"索引"},"/mysql/log/":{"data":{"":"redo log 重做日志 主要是记录更新操作的细节，然后记录到文件中，为了mysql崩溃时能够恢复 可以保证事务的持久性 为什么需要这个redo log\n数据是存放在磁盘上，用户是通过cpu来操作的，两者之间速度是非常慢的，通常是需要缓冲池（是内存中的一个页面）作中间缓冲，缓存表数据与索引数据，避免多次磁盘IO。 但是一个更新操作完成后，代表这有数据变了，磁盘上的数据要更改。先更新了缓冲池，但是mysql进程挂了，后续无法操作，导致磁盘中没有更新，造成数据丢失。 有一个暴力解决： 可以在事务提交之前，将数据刷新到磁盘中 但会出现多次随机IO，导致速度会非常慢 所以redo log file就出现了，它可以记录每次更新操作，只要将更新详细细节追加到这个文件中，就代表着事务提交成功。 其中细节：\nredo log file出现了，但是这个文件还是在磁盘上的，如果每次事务都进行刷盘，还是会有多次磁盘IO 所以还可以在内存中申请一个缓冲池redo log buffer，记录redo log信息 所以会有一个概念“何时将缓冲池redo log buffer的数据写入到磁盘redo log file文件中？” 刷盘策略 重要的概念，刷盘不是直接写入到磁盘的redo log file，而是写入到文件系统的Page Cache。\n参数：innodb_flush_log_at_trx_commit控制 缓冲池大小快满的时候 后台线程控制 mysql实例关闭时 innodb_flush_log_at_trx_commit 0：每次事务提交不操作，而是由后台线程来控制，每隔1秒进行刷盘，最多丢失1秒的数据 1：默认的，也是保证持久化必须的，每次事务提交就刷盘，通过fsync从页缓存写入到磁盘中 2：文件系统的页缓存，事务提交，刷新到页缓存，再由页缓存刷新到磁盘 后台线程 innodb有一个后台线程Page Cleaner Thread，会每隔一秒将redo log buffer的数据写入到page cache，然后调用fsync从页缓存中写入到磁盘，但是刷新的是脏页，未修改的数据页是不会刷新的 日志文件组 mysql里不止一个redo文件，在mysql8中默认32个文件，采用环形数组存储。 write pos：代表当前写入的位置，后移操作。 check point：检查点，代表擦除的位置，后移操作。 write pos之后和check point之前，这两个之间代表是可以写入数据的部分。 bin log redo log是保证事务的持久性，是属于InnoDB的 bin log二进制日志，是记录更新语句的原始逻辑，类似于Redis的AOF机制，可以保证一致性 作用 主从复制 主节点将操作写入到bin log文件中 从节点从bin log文件中获取详细信息，实现数据同步 审计、监控 数据恢复 可以恢复指定时间点的数据 重新执行sql语句 记录格式 statement 记录语句的原始状态，可以理解成一模一样 会出现数据不一致的问题，如插入语句中有now()，date()函数之类的。 row 记录语句的更新的具体数据 但是会导致文件比较大 mixed 会先判断语句是否会导致不一致的问题 再去决定用什么存储 具体细节 和redo log一样，还是在内存有一个缓存，binlog cache，在磁盘中还有一个binlog file binlog的是以事务为单位的，只有在事务提交后，才会记录，写入文件。 刷新binlog cache时机，由变量sync_binlog决定 0，事务提交后，不刷新，由系统决定 N，累积N个事务后，刷新缓冲区，执行fsync命令，刷入磁盘 undo log 重做日志 实现回滚，当一个事务异常后，可以根据这个文件进行回滚操作。 问题 脏页 内存区和磁盘区的数据不一致，此时内存区的数据页称为”脏页“ 即便不一致，但是有redo log，也无妨 “脏页”变成“干净页”"},"title":"日志"},"/mysql/transaction/":{"data":{"":"概念 是指一组逻辑操作，看成一个实体，这些操作要么全部正确执行，若出错一个在全部不执行，不造成修改操作。 事务使用 设置隔离级别：set session transaction isolation level read uncommited; 开启事务：start transcation 设置保存点：savepoint 提交事务：commit 回滚事务：rollback 回滚到保存点：rollback to ACID 利用 AID来保证最终的C\n原子性 atomic：事务的所有操作要么全部执行成功，要么全部执行失败。 一致性 consistency：事务执行之后，数据应该保持一致，如修改前后资源的平衡。 隔离性 isolation：事务与事务之间应该相互隔离，互不影响。 持久性 durable：事务执行后的操作结果应该是持久的。 问题 假设两个事务：T1，T2\n脏读：T1查询到了T2修改的数据，但是T2没有提交，这时T2可以随时回滚，抛弃它自己修改的数据；然后T1若是对自己查询的数据进行操作，就会出现最终数据错误。 不可重复读：T1在一直读取数据的时候，这时T2对这一个数据进行了修改，导致T1读取的数据变了。 幻读：T1在查询一个区间时，突然T2向这一个区间插入了一个新数据，导致T1再次查询时，出现了不认识的新数据，就像出现了幻觉一样。 修改丢失：T1和T2读取同一个数据然后进行修改，会出现T1的修改被T2的修改替换了 隔离级别 代表的是多个事务之间占用相同的资源是如何隔离的 解决事务之间的问题 READ-UNCOMMITTED 读未提交 允许一个事务读取另一个事务未提交的修改数据 都不能解决 READ-COMMITTED 读已提交 允许一个事务读取另一事务已提交的数据 脏读能解决，因为此隔离可以防止读取未提交的数据 不可重复读、幻读不能解决 REPEATABLE-READ 可重复读 对同一字段多次读取结果都是一致的 脏读能解决 不可重复读能解决，共享锁 幻读不能解决，也可以解决，如记录锁和间隙锁 SERIALIZABLE 串行 事务一个一个执行，不存在并行，也就不存在并行事务带来的问题 都能解决；通过加锁 锁 按照模式上分类：\n乐观锁 悲观锁 按照粒度上分类：\n全局锁 表级锁 页级锁 行级锁：在存储引擎之上的，利用索引机制来进行加锁 按照属性上分类：\n共享锁 S锁：读锁，在多个事务中可以多次获取这个锁进行操作，同一时刻可以多个线程拥有\n排它锁 X锁：写锁，独占的，其他事务对其不能再加锁，同一时刻只能有一个线程拥有"},"title":"事务"},"/pay/":{"data":{"":"关于现在支付功能 现在的流程：\n自己的系统对接支付平台\n支付平台提供接口，然后自己的系统调用接口，提供一些参数\n支付平台返回一些参数，比如返回一个支付页面，或者调起支付app，供用户支付\n其中，自己的商家需要在支付平台注册，保证，收款、付款都能到自己的账户中\n所以，自己的账户就需要各种id，保证唯一"},"title":"支付功能"},"/pay/alipay/":{"data":{"":"介绍 H5支付 H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。\n准备 接入商户或者服务商 申请参数：appid 、mchid、apikey、cert、key 开发准备 H5支付域名 售卖产品/使用场景的描述 所售卖产品对应的官方网站域名或详情页网址 参数 AppID：商户应用载体的AppID，可以是公众号，小程序或App mchid：商户在微信侧申请入驻的收款账号 API v3密钥：商户在商户平台设置的API v3密钥，主要用于对敏感字段信息的加密或解密，具体设置流程请参考各产品接入前准备说明 商户API证书：商户在商户平台下载的证书，主要用于API请求的签名生成及验证，具体下载操作说明请参考各产品接入前准备说明 OpenID：用户在直连商户应用下的用户标示 开发 准备好参数\n了解好v2、v3接口的规则\n在调用微信支付接口时，了解好对应的规则 确定接口的请求地址、请求参数、请求方式、回调内容 "},"title":"支付宝支付"},"/pay/wx/":{"data":{"":"介绍 H5支付 H5支付是指商户在微信客户端外的移动端网页展示商品或服务，用户在前述页面确认使用微信支付时，商户发起本服务呼起微信客户端进行支付。\n准备 接入商户或者服务商 申请参数：appid 、mchid、apikey、cert、key 开发准备 H5支付域名 售卖产品/使用场景的描述 所售卖产品对应的官方网站域名或详情页网址 参数 AppID：商户应用载体的AppID，可以是公众号，小程序或App mchid：商户在微信侧申请入驻的收款账号 API v3密钥：商户在商户平台设置的API v3密钥，主要用于对敏感字段信息的加密或解密，具体设置流程请参考各产品接入前准备说明 商户API证书：商户在商户平台下载的证书，主要用于API请求的签名生成及验证，具体下载操作说明请参考各产品接入前准备说明 OpenID：用户在直连商户应用下的用户标示 开发 准备好参数\n了解好v2、v3接口的规则\n在调用微信支付接口时，了解好对应的规则 确定接口的请求地址、请求参数、请求方式、回调内容 "},"title":"微信支付"}}