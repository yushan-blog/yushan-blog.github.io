{"/blog/":{"data":{"":""},"title":"Java知识"},"/guide/":{"data":{"":""},"title":"Guides"},"/guide/hugo/use/":{"data":{"使用流程#使用流程":"注：命令要在站点根目录下运行\n发布站点 hugo new site blog 安装主题 从git中寻找，clone到本地站点中的themes文件夹中 创建内容 hugo new guide/hugo/index.md ","安装#安装":"安装apt install hugo"},"title":"Use"},"/java/":{"data":{"":""},"title":"Java"},"/java/basic/":{"data":{"":""},"title":"Java基础知识"},"/java/basic/basicknowledge/":{"data":{"":"","string#String":" 构造之后不可以改变 因为字符数组是private修饰的，然后没有对外提供public方法改变 而且final修改String类，不可以被继承。 每次String类型的对象操作时，都会产生一个新的String对象 StringBuilder\n线程不安全，提供了修改字符串的操作 toString方法，返回一个String对象 修改操作是扩大字符数组的容量 StringBuffer\n线程安全，public方法全是synchronized，也提供了修改字符串的操作 toString方法，返回一个String对象 修改操作是扩大字符数组的容量 ‘+’ 和 StringBuilder\n+操作，每次都会创建一个StringBuilder对象操作append，然后返回一个String StringBuilder不会 ","对象的比较#对象的比较":" 当是基本类型的时候，比较的是值 当是引用类型的时候，比较的是引用地址 equals() 这是一个方法，默认Object的是比较引用地址 由于每一个类都默认是Object的子类，所以可以重写这个方法，自定义相等的逻辑 重写要符合的规则：\n自反性：x.equals(x)应该返回true，也就是除了null之外，自身应该与自身相等 对称性：对于x，y。x.equals(y)应该和y.equals(x)的返回值相等 传递性：对于x，y，z。x.equals(y)、y.equals(z)的返回值为true，x.equals(z)也应该为true 一致性：如果对象没有改变，那么反复调用返回值应该一样 重写的技巧：\n先比较引用是否相等 检测是否为null，为null直接返回false 根据语义 如果在子类中比较语义改变了，则使用getClass()判断实际类型，实际类型相等时才进行比较。 如果不变，比如只比较名字等等，采用instanceof关键字判断是否属于相同的父类即可，这里要注意递归栈溢出的情况。 然后在比较属性 @Override public boolean equals(Object other){ if(this==other) return true; if(other==null)return false; if(!(this.getClass()==other.getClass())return false; if(!(other instanceof OtherObject)) return false; //比较属性 } hashCode() 默认的是由线程局部状态产生的随机数，而不是地址转换的，但是String重写了hashCode()，所以散列码可能会相同哦 地址转换的code需要通过VM参数设置 -XX:hashCode=4 为什么使用： 如数据结构Map，键值对的结构，通过一个key，来快速的确定一个value，通常用于快速查找的场景。但是这个key如何设置呢，以便快速的在数据结构中查找。比如简单的通过一个用户id，来确定一个用户，在这个时候，id就可以很快速的在数组中获得value。 但是在复杂的情况，如何通过一个字符串来确定一个对象呢，字符串通过数组查找是实现不了的吧。所以对字符串进行散列，散列的意思就是将一个元素转换为一个整数，通过这个整数尽可能地能够代表这个元素。所以在使用Map的时候，如果使用字符串作为key，在存入的时候，将这个元素散列，就可以快速的查找value了。\n和equals()的关系： 散列会有问题，每个元素不可能散列到不同的整数，总会有冲突的，所以散列码hashcode相等不代表元素就相等。所以还是要采用equals来具体的判断元素是否相等。在Java Map中，都是先通过hashcode插入元素，不相等的hashcode视为不相等的元素会直接添加，如果hashcode相等，再通过equasl方法判断是否真的相等，相等就不加入了。 而且速度还会比equals判断快，在中间加入一层hashcode的判断，可以提升性能，所以设计的优秀的散列函数是非常有必要的。\n重写之equals()和hashCode() hashCode，相同的元素的散列码应该是相等的，不相同的元素的散列码极小可能是相同的 散列码关注的是性能，更倾向于 不相等的元素应该产生不相等的散列码 重写equals()方法没有重写hashCode()，会出现相同的元素产生的散列码不同，然后添加到map中，第二次获取不到 ","接口和抽象类#接口和抽象类":" 概念上 接口：强调的是对象的行为，强调类应该做什么，比如一个接口里有一个跑步的行为，然后一个类实现了这个接口，那么就代表这个类具有的跑步的行为。 抽象类：强调代码复用，定义一种通用的模板，提供一些共性的状态和行为。 使用上 接口：interface关键字，方法都是 public abstract，常量都是public static final且必须有默认值 抽象类：abstract关键字，可以有实例方法和抽象方法，抽象方法必须无实现 共同 都不能被实例化 都可以有default方法 都可以有抽象方法 ","数据类型#数据类型":"byte、short、int、long、float、double 、char 1、2、4、8、4、8 、2\nboolean\n单个boolean变量占用的是4个字节，因为在存储的时候使用的是int boolean数组，每个元素占用1个字节，因为在存储的时候，虚拟机会转换为byte数组 ","面向对象三大特性#面向对象三大特性":"继承 如果多个实体有共同的状态和行为，可以将这些共同的状态和行为提取出来，然后形成一个单独的实体，那些实体可以继承这个新的实体，达到复用的目的，而且容易维护。 阻止继承：类使用final关键字声明，之后这个类不能被继承，然后方法也自动是final方法。 继承：是实现了类之间的 is-a 关系 封装 信息隐藏，形式上是将对象的数据和行为组合在一个类中，并且对使用者隐藏具体的实现细节 重要：程序只能通过对象的方法才能和对象的数据进行交互，使用者是看不见数据的 多态 指一个对象有多种状态，主要分为编译时多态，运行时多态 编译时多态：方法的重载 运行时多态：程序中定义的对象引用所指向的具体类型在运行期间才确定 对象的方法调用：\n确定对象的实际类型 匹配方法 采用动态绑定/静态绑定 静态绑定：构造器、private、static和final方法，这些方法编译器能够明确，称为静态绑定 动态绑定：除了以上，必须采用动态绑定， 虚拟机必须调用与 a对象引用的实际类型对应的方法，如果在实际类型没有找到，必须在超类中调用，但是这个过程慢，所以虚拟机生成方法表，列出所有方法的签名和要调用的实际方法。 调用方法，从方法表（虚拟机加载一个类时创建）中 如下： Manager 继承 Employee 当一个 manager 对象调用getName方法时，直接查表就知道该调用哪个方法\npublic class Employee{ private String name; private int salary; public String getName(){ return name; } public String getSalary(){ return salary; } } 方法表大概为： Employee getName\t-\u003e Employee.getName() getSalary -\u003e Employee.getSalary() public class Manager extends Employee{ private String id; public String getName(){ return name; } public String getId(){ return name; } } 方法表大概为： Manager getName\t-\u003e Manager.getName() getId\t-\u003e Manager.getId() getSalary -\u003e Employee.getSalary() ","面向对象和面向过程#面向对象和面向过程":"面向对象 OOP：\n将现实世界的实体所拥有的状态和行为封装成一个类，以面向这个实体的方式进行程序构建，在实体的主观感受操作。 通过对象来描述现实世界中的实体以及它们之间的交互关系。 状态-\u003e属性 行为-\u003e方法 面向过程 PP：\n主要强调的是程序执行的流程，以函数和数据结构为基础进行编程 程序量比较大时程序难以维护 "},"title":"概念"},"/java/basic/collection/":{"data":{"":"","concurrenthashmap#ConcurrentHashMap":"数据结构：\n1.7及以前：采用Segment数组+Entry数组+链表，可以代表着并发级别，每一个Segment锁住一部分数据，可以保护并发安全性。Segment继承了可重入锁 1.8：采用Node数组+链表/红黑树，和HashMap一样。然后锁的层面采用synchronized+CAS。锁的粒度为 Node数组的节点，synchronized只锁定当前链表或红黑二叉树的首节点，也就是只对hash一样的节点加锁，粒度更低，并发量更高 cas操作，体现在经过hash判断节点没有值，采用CAS操作向Node数组添加值 synchronized操作，体现在判断之后，出现冲突，加锁，处理冲突，添加值 复合操作的原子性\n当有检查操作之后还有添加操作，这两个操作不是原子的，会有线程不安全的问题 CHM提供了方法可以直接使用，不建议加锁 ","hashmap#HashMap":"","hashtable--过时#HashTable  过时":" 也是key-value结构 线程安全，所有的公有方法都用 synchronized关键字修饰 解决冲突：链表 扩容：2n+1，初始默认11 先确定容量：2n+1 再重构所有元素hash，然后确定新数组的index位置 添加元素 先判断index=hashCode()%len 遍历entry.next，查看是否有相等的，若相等则直接替换，采用的是 头插法 ","linkedhashmap#LinkedHashMap":" 集合是存放对象的容器，用来存放对象的引用 线程安全的集合类\nVector：老版本的，加了一个synchronized HashTable：老版本的 ，加了一个synchronized ConcurrentHashMap：并发HashMap，以前是锁住一个段，现在是锁住一个桶 Set 在java的大部分实现类，都是采用了Map，value都是一个final Object对象，key算是自己添加的值，也就是集合的值 HashSet 集，存储的元素不相等的 无序，添加元素的顺序和存储的顺序是不一样的， 也可以保证有序，如LinkedHashSet，构建时传入一个dummy（true）作为第三个参数，会创建一个（LinkedHashMap） 底层直接使用HashMap存储，value是一个固定的对象，key的hash判断不相等是不添加的，相等时也就是默认的替换老值。 扩容机制都是采用HashMap的 是如何保证不重复的？\n是直接利用了HashMap的putVal方法 如果两个key相同，这直接替换掉了 LinkedHashSet 有序的集，直接继承HashSet 创建时dummy设为true，后续使用包级别的构造方法创建LinkedHashMap TreeSet 底层使用了TreeMap 采用红黑树，保证了元素的有序 List 是一个列表 就是数据结构的线性结构 ArrayList 存储数据还是 Object[]数组，返回元素时，是进行泛型类型的转换，也就是Object-\u003e变为 E 支持基于下标的快速访问 插入O(1)，删除O(N) 容量机制\n默认为 10个元素 扩容数组长度：1.5倍，new=old*1.5 size：数组实际元素的个数，也就是实际存在的元素 Array 是java用来存储相同类型元素，必须在使用前指定大小，通过索引机制访问元素 所以不可以扩缩容 是一种引用数据类型 如下，names、ages变量，它们是一种引用数据变量，当使用new关键字时，会在堆中创建连续的内存空间（每一个内存空间的大小，在类加载阶段就能确定），在虚拟机栈中会存储引用数据变量的具体指向地址 String[] names=new String[10]; int[] ages=new int[10]; User[] users=new User[10]; LinkedList 底层是 Node节点，使用链表的形式存储元素 默认是插入尾部 区别\n线程都不安全 ArrayList查询速度快 LinkedList插入，删除速度快 Queue 先进先出的特性 判断队满：head=(tail+1)%size 判断队空：head=tail HashMap size：是key-value的个数 length：是Node数组的长度 初始容量：16 最大容量：2的30次方 默认加载因子：0.75 ，泊松分布确定 阈值：是扩容的时候，是size\u003ethreshold 。每次扩容新的threshold=新的容量newcap*loadFactor；但是指定长度时，阈值为大于容量的最小2的次幂的值， 添加元素的流程 指定加载因子和阈值 默认Node数组长度为16 向map加入值时，先检查当前Node数组是否为空或者长度为0； 如果为空或者长度为0， 则进行Node数组的扩充 否则，进行hash求余，判断位置所在的Node元素是否为空， 如果为空，直接创建，填入。 否则，解决hash冲突，然后向链表/红黑树添加元素。 先判断是否是红黑树，如果是，则向红黑树添加元素。 如果是链表，则在尾部添加元素，如果链表长度大于等于 8,则需要转化红黑树。 数组的长度扩充 如果Node数组为空、长度为0或者Map键值对的数量大于阈值，会进行扩容 Node数组的长度以2的倍数进行扩充 new=old«1 final Node\u003cK,V\u003e[] resize() { Node\u003cK,V\u003e[] oldTab = table;//老的Node数组 int oldCap = (oldTab == null) ? 0 : oldTab.length;//数组长度 int oldThr = threshold;//老的阈值，阈值也是两倍扩容 int newCap, newThr = 0; if (oldCap \u003e 0) { if (oldCap \u003e= MAXIMUM_CAPACITY) { //这一步是容量最大了，不能扩容了 threshold = Integer.MAX_VALUE; return oldTab; } else if ( (newCap = oldCap \u003c\u003c 1) \u003c MAXIMUM_CAPACITY \u0026\u0026 oldCap \u003e= DEFAULT_INITIAL_CAPACITY ) newThr = oldThr \u003c\u003c 1; // 双倍阈值 } //这一段都是初始化工作，这就是默认容量为16,阈值为16*0.75的原因 else if (oldThr \u003e 0) // initial capacity was placed in threshold newCap = oldThr; else { // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } threshold = newThr;//属性重新赋值 Node\u003cK,V\u003e[] newTab = (Node\u003cK,V\u003e[])new Node[newCap]; //处理值 table = newTab; if (oldTab != null) { //这一段就是深度遍历Node[]数组，重新赋值 //如果没有冲突，重新利用key的hash和(新长度-1)异或运算即可 //有冲突，检查链表还是红黑树，之后重新赋值即可 } return newTab; } 确定hash值 HashMap的hash方法是Object的hashCode()，和hashCode的16位后缀进行异或运算。 key可以为null，hash值为0 key在Node数组的位置：i=(n-1)\u0026hash //这个是HashMap中求hash的值 static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u003e\u003e\u003e 16); } //这个就是putVal方法中，计算索引下标 int i=(n - 1) \u0026 hash; Node\u003cK,V\u003e p = tab[i]; 转化红黑树： 先判断当前Node结点所尾随的链表长度是否\u003e=8，如果大于则进行转换操作的判断 转化：首先判断Node结点数组的长度是否小于64 。 a. 如果小于64 ，则先进行数组扩容 只有链表长度\u003e=8 ，Node数组长度\u003e=64，才会转化红黑树 线程不安全 插入时：假定A,B两个线程处理的key出现冲突，并且计算的index一样；此时，A线程时间片使用完毕，B线程进行处理，插入数据，但是A线程活动时，会替换掉B线程处理的数据。 size：检查size和增加size ，这两个操作不是原子的；最终会导致size只增加1个。 LinkedHashMap 概念 继承了HashMap 采用双向链表，保证插入顺序和输出`顺序的一致性 图片 accessOrder 这个属性决定了 每次访问某个key-value之后是否移动到链表的尾部 默认为false，在创建时可以指定 使用这个可以实现 输出顺序和访问顺序一样，链表的头部是最久未访问的元素 removeEldestEntry() 结合accessOrder，可以包装一个简易的LRU缓存 这个方法由afterNodeInsertion()调用，这个方法是进行移除首节点的操作，由一个参数evict控制。可以在HashMap的putVal()源码中看见最后调用了这个方法，只是HashMap里的是一个空方法。由于这个LinkedHashMap没有重写put操作，所以最后是否移除首节点，就有这个方法来控制了， public V put(K key, V value) { return putVal(hash(key), key, value, false, evict-\u003etrue); } protected boolean removeEldestEntry(Map.Entry\u003cK,V\u003e eldest) { return false; } //重写 protected boolean removeEldestEntry(Map.Entry\u003cK,V\u003e eldest) { return size() \u003eMAX_ENTRIES; } 可以重写这个方法，返回true，就可以实现移除首节点，释放空间了","list#List":"","queue#Queue":"","set#Set":""},"title":"集合"},"/java/jvm/":{"data":{"":""},"title":"JVM"},"/java/jvm/memory-region/":{"data":{"":"","java内存区域#Java内存区域":"内存区域图 jdk1.8以前：\njdk1.8及以后：\n对于线程和进程的职责：\n线程独有\n程序计数器、本地方法栈、虚拟机栈 线程共享\n堆区、元空间 程序计数器 在计组中，PC为控制器里面的一部分，它记录的是下一个指令所在的地址，用于指令跳转 在java中\n记录的是当前线程正在执行的字节码的指令地址，也就是行号 因为在多线程的情况下，每一个线程都会有自己的程序计数器，然后在线程切换的时候，用于恢复现场，继续执行 程序计数器是一个很小的内存空间，它仅仅记录的是一个指针 线程私有的，生命周期跟随线程 是唯一一个没有OOME的区域 虚拟机栈 栈是一个先进后出的数据结构，这就符合方法的递归调用的应用，一个方法调用另一个方法，这就符合栈的特性 在java中，虚拟机栈应用在存储方法调用使的局部变量、操作数等信息 异常\nStackOverflowError：方法调用太深，虚拟机栈太深 OutOfMemoryError：虚拟机栈申请不到内存 如图：\n局部变量表 存储方法的形参、方法内的局部变量，每一个局部变量有一个索引值，用于快速访问 局部变量必须初始化才能使用 操作栈 可以回想一下（2-3）*4，这个表达式的算法该怎么设计，利用两个栈，然后再利用操作符号的优先级，进行入栈、出栈的操作。还有前缀表达式、后缀表达式。 在java中\n是字节码指令执行过程的临时存储 由于局部变量表存储的是变量，而操作栈就可以动态的处理变量，进行一个中转站的使用 动态链接 回想多态特性的运行时多态，方法的具体调用要到运行期间也能确定 这个动态链接存储的是量池里的该方法的引用，支持调用过程中的动态链接。 方法返回地址 要保证每一个方法执行完之后应该返回到正确的位置，接着上一个方法的执行。 此时的操作就是弹出当前栈顶的栈帧 本地方法栈 和虚拟机栈类似，不过本地方法栈记录的是native方法的信息 native方法：\n用于在jvm上调用操作系统层面的方法，由c++/c语言编写的 堆区（heap） 在该区域中，主要用来存放对象实例，也是垃圾收集器的主要工作区域。\n分代回收算法，越老的区，垃圾回收频率越低（使用次数晋升）堆区划分：\n新生代 老年代 逃逸分析\n如果某些方法中的对象引用没有被返回（return）或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存 字符串常量池 因为在程序中字符串的使用占大量，所以单独开辟一个区域用于快速访问内存中字符串变量的信息。 字符串常量池可以看作是一个map，其中value用于映射堆区中的地址 它的实现是一个stringtable 历史\njdk1.7以前，是在永久代中 jdk1.7及以后，移动到堆区中了 为什么：在永久代中垃圾回收效率低，没有堆区GC效率高 方法区 方法区是一个概念，它是一个逻辑区域，在运行时，需要读取各种类的信息，如字段信息、方法信息、常量、静态变量等等，方法区就是把这些信息划分出来的一个单独区域。 永久代、元空间\n它俩是方法区的实现方式 永久代是在jvm运行时内存区域，然后容易OOM 元空间是在本地内存上的实现 运行时常量池 用来存储class文件中的各种字面量和符号引用 它相当于是class文件常量池在内存中的映射 字面量：\n是在源代码直接出现的值，可以是数字、字符 如 int a=12; String s=“abc”; class文件常量池\n常量池，名字没什么大不了，池没什么大不了 这个东西就是编译器编译.java文件时，生成的.class文件，这个文件可以看作一个数据结构，存放类的信息，代码的信息，常量的信息等等。这些东西能够在编译器就能够确定，就先单独存储起来，以便快速的访问 符号引用和直接引用\n符号引用\n直接引用"},"title":"Java 内存区域"},"/java/third/one/":{"data":{"":""},"title":"One"},"/java/thread/":{"data":{"":""},"title":"多线程"},"/java/thread/basic/":{"data":{"condition#Condition":"","java内存模型#Java内存模型":"","java层面#Java层面":"","lock#Lock":"也是锁的概念，比关键字synchronized提供了更广泛的功能。锁是多个线程对共享资源访问的工具，锁提供了对共享资源的独占访问。 可以按照灵活的访问对共享资源进行同步控制\npublic interface Lock { //获取锁，如果锁不可用，则当前线程变为等待状态 void lock(); //获取锁，如果锁不可用，则当前线程进入等待状态，并且能够响应中断。 void lockInterruptibly() throws InterruptedException; //尝试获取锁，如果锁可用则获取并返回true，否则返回false。 boolean tryLock(); //尝试获取锁，如果在给定的时间内锁变得可用，则获取锁并返回true，否则返回false。 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //释放锁 void unlock(); //创建一个新的Condition并且绑定到这个Lock对象上 Condition newCondition(); } ","readwritelock#ReadWriteLock":"读写锁\n读取锁：如果只是读取共享资源的操作，那么就没有并发问题，可以让多个线程并发访问 写入锁：该锁还是让同一时刻只有一个线程去访问共享资源 public interface ReadWriteLock { Lock readLock(); Lock writeLock(); } ","reentrantlock#ReentrantLock":" 对于线程来说，是一个可重入锁，这把锁将由最近成功获得锁，并且还没有释放该锁的线程所拥有。当锁没有被另一个线程所拥有时，调用 lock 的线程将成功获取该锁并返回。如果当前线程已经拥有该锁，此方法将立即返回，这就是可重入锁的概念 还支持一个公平的概念，若创建时设为true，则空闲锁将由等待时间最长的线程持有（synchronized在对象的等待队列中，每次notify是随机的） public class Main{ public ReentrantLock lock =new ReentrantLock(); public void test(){ lock.lock(); try{ //method body }catch(Exception e){ }finally{ lock.unlock(); } }\t} 流程\n分为公平和非公平两种模式（讨论非公平，默认的） 当执行lock()时，进行上锁，利用CAS操作，将state从0设为1，成功的话就state的拥有者就设为当前线程 如果将state从0设为1不成功，再试着获取一下锁，进行下一步 重入的情况：state肯定是大于0的并且当前线程是持有线程的时候，这时候只要增加state的数值即可，返回true。 竞争失败的情况：state不为0且当前线程不是持有线程，直接返回flase 后续将竞争失败的线程作为一个Node，添加到队列中 释放锁时，要注意，加锁多少次就要释放多少次，不然state回归不到0值，其他的线程会一直加锁不成功 state从0设为1失败：\nfinal boolean nonfairTryAcquire(int acquires) { final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) { //没有线程了 if (compareAndSetState(0, acquires)) { setExclusiveOwnerThread(current); return true; } } else if (current == getExclusiveOwnerThread()) { int nextc = c + acquires; if (nextc \u003c 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; } return false; } 释放锁的例子：\n此时第一个线程加锁两次，之后state为2 但是释放锁就一次，所以state为1 第二个线程加锁就会失败，造成死锁问题，程序不会停止，因为线程会一直等待 //源代码 protected final boolean tryRelease(int releases) { int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) { free = true; setExclusiveOwnerThread(null); } setState(c); return free; } public class SyncTest2 { public static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) { new Thread(()-\u003e{ lock.lock(); lock.lock(); try { System.out.println(\"1\"); }finally { lock.unlock(); } }).start(); new Thread(()-\u003e{ lock.lock(); try { System.out.println(\"2\"); }finally { lock.unlock(); } }).start(); } } 代码：\n方法的执行由抽象静态内部类Sync来执行（存在的理由是由于公平/不公平的原因） 最后锁的控制操作是由AQS来实现的 ","reentrantreadwritelock#ReentrantReadWriteLock":" 支持可重入的读写锁 也支持公平和不公平 支持锁的降级，从写入锁降级到读取锁 ","runnable#Runnable":"","synchronized#synchronized":"这是java的关键字之一，通常用来维护一个同步代码块，可以应用在方法上、对象上。 synchronized 方法或语句的使用提供了对与每个对象相关的隐式监视器锁的访问，但却强制所有锁获取和释放均要出现在一个块结构中：当获取了多个锁时，它们必须以相反的顺序释放，且必须在与所有锁被获取时相同的词法范围内释放所有锁","thread#Thread":"","使用#使用":"修饰静态方法\npublic class SyncTest1 { private static int sum = 0; private synchronized static void add(){ SyncTest1.sum++; } public static void main(String[] args) throws InterruptedException { int nums = 10; Thread[] ts = new Thread[nums]; for (int i = 0; i \u003c nums; i++) { ts[i] = new Thread(() -\u003e { for (int j = 0; j \u003c 1000; j++) { SyncTest1.add(); } }); ts[i].start(); } for (Thread thread : ts) { thread.join(); } System.out.println(\"SyncTest num: \" + SyncTest1.sum); } } 通过关键字sync修饰SyncTest1类中的静态add方法，每个线程必须获得该类的Class对象的锁，才能够去执行方法，可以保证操作的正确。 修饰实例方法\nclass Share{ private int num=0; public synchronized void add(int a){ num+=a; } public int getNum(){ return num; } } /** * 测试同步 */ public class SyncTest1 { private static int sum = 0; public static void main(String[] args) throws InterruptedException { int nums = 10; Thread[] ts = new Thread[nums]; Share share=new Share(); for (int i = 0; i \u003c nums; i++) { ts[i] = new Thread(() -\u003e { for (int j = 0; j \u003c 1000; j++) { share.add(1); } }); ts[i].start(); } for (Thread thread : ts) { thread.join(); } System.out.println(\"share num: \" + share.getNum()); } } 通过关键字sync修饰Share类中的add方法，每个线程必须获得对象实例share的锁，才能够去执行方法，可以保证操作的正确。 修饰代码块\npublic class SyncTest1 { private static int sum = 0; public static void main(String[] args) throws InterruptedException { int nums = 10; Thread[] ts = new Thread[nums]; Object object=new Object(); for (int i = 0; i \u003c nums; i++) { ts[i] = new Thread(() -\u003e { for (int j = 0; j \u003c 1000; j++) { synchronized (object) { sum++; } } }); ts[i].start(); } for (Thread thread : ts) { thread.join(); } System.out.println(\"Sum: \" + sum); } } 通过使用关键字sync修饰object对象，使每个线程都需要获得object对象的锁才能进行代码的操作，就可以保证sum变量的正确操作。 区别 修饰静态方法，锁住的是当前类的Class对象（加载到内存时，创建的class对象），因为静态方法、静态变量都属于类，所以每个线程要执行/获取类的信息，必须要获得类对象的锁 修饰实例方法，锁住的是当前实例对象，实例方法需要对象来执行 修饰代码块 synchronized(obj)：锁住的是对象实例 synchronized(Share.class)：锁住的是类对象 注意：\n首先要注意的是对象实例的锁和类对象的锁不互斥，两个对象不一样，锁就不一样，在方法内调用是可以的。 ","创建和使用线程#创建和使用线程":"","原子性#原子性":" 确保一系列操作要么全部完成，要么完全不执行。这意味着在执行过程中，不会被其他线程打断 ","原理#原理":"修饰代码块的字节码情况：\n有一个monitorenter，两个monitorexit，因为，sync最终使用的还是获得对象的监视器的权力(Monitor)\n修饰方法的字节码情况：\n它没有monitorenter和monitorexit，取而代之的是一个flags标志 ACC_SYNCHRONIZED","可见性#可见性":" 当一个线程修改了共享变量的值时，其他线程能够立即看到这个修改。这保证了数据的一致性和同步性。 ","多线程#多线程":"","对象监视器monitor#对象监视器（Monitor）":"对象的监视器是一种同步机制。在java中，基于操作系统的互斥信号量（mutex），一个监视器对应一个对象，负责多个线程对这个对象的访问。 所以，在synchronized使用时，一个monitorenter可以看作成是P操作，一个monitorexit可以看作成V操作，通过操作监视器的值，保护这个对象的同步访问。","并发并行#并发/并行？":"","并发编程的特性#并发编程的特性":"进程/线程cpu:\n中央处理器 是一个特殊的处理器，负责解析和执行计算机程序的指令 架构： SMP：对称多处理器，多个cpu相同对待，共享内存、总线 AMP：异步多处理器，每个cpu有自己的内存、总线资源，通信采用共享内存 多核：\n将cpu划分为多个core，形成一个个独立单元，可以独立执行任务 所以并行执行进程/线程是可以的 intel 4核8线程：这个8线程是指超线程，将每个核心划分两个逻辑核心，防止资源的浪费，4核就是cpu具体的核心数了。 内核：\n是指在一个cpu处理器中，划分出来的一部分，主要功能和其他部分不同 它负责管理软件部件（进程） 虚拟内存：\n它是假的“内存”，让程序认为他自己所占用的内存空间是连续的，实际上是有可能不连续的。 它和物理内存的映射关系，将采用页表的形式记录下来，还有快表这个缓存。 它通过文件的形式记录程序的数据和地址，在所需要的数据不再内存中时，才加载到物理内存中。 进程 用来支撑程序运行的东西，用来分配和管理程序所要使用的资源，当然也是计算机分配资源的基本单位 由操作系统进行管理进程 线程 是更小的单位了，在进程运行时可以产生多个线程，每个线程可以处理自己的资源，并且还会共享进程的内存空间和资源量。 CPU进行使用的基本单位 用户线程/内核线程 用户线程：由用户空间程序管理的线程，创建和切换成本低，不可以利用多核 内核线程：由内核管理的线程，创建和切换成本高，可以利用多核 线程模型 用户线程和内核线程之间的关联方式、调度方式，用户线程的创建、操作都会映射到内核线程上，处理多线程的并发执行\n一对一：一个内核线程对应一个用户线程 一对多：一个内核线程对应多个用户线程 多对多：多个内核线程对应多个用户线程 为什么会有呢？\n时间片切换：在资源方面，出现竞争关系，将采用时间片切换算法，将每一个进程分配一定的时间，比如50ms，时间一到，将保存该进程运行的状态，如内存里的值、寄存器状态，这些关于自己的状态，被称为上下文。这些操作需要大量的时间，进程的消费比较大，进程有自己的虚拟地址空间，然而线程就可以共享进程的空间，在切换时消耗小。 虚拟内存：进程在运行初，会申请内存；虚拟内存和物理内存存在映射，也就是页表，切换时需要保存页表，还有其他的快表（TLB、缓存），切换会被清空 任务并发：在一个程序运行时，当有多个独立任务时，采用多个线程可以快速的完成，再加上会共享进程的内存空间，而且线程不会切换上下文，很快。 并发/并行？并发（Concurrent）：\n是指在一个时间段内，多个线程争抢一个cpu资源，然后无法并行操作，cpu只能进行时间片切换，会出现线程的挂起等操作，这中现象就是并发。 并行（Parallel）：\n是指在某一时刻（同时），多个任务一起执行 在cpu的核心数足够的时候，多个进程可以很好的运行在多个核心上，不出现竞争关系，这称为并行。 Java层面多线程 为什么要有多线程？\n一个线程处理任务慢，采用多个线程利用多个核心运行，在不出现竞争资源的时候，执行速度杠杠的。 带来的问题：\n共享进程的内存空间，若是出现竞争资源的关系，需要额外的处理 死锁问题：两个线程都“吃着碗里，看着锅里” 内存泄漏：线程创建的对象没有释放 在单核cpu运行多线程呢？\n这要取决与线程的任务类型，比如cpu密集型，它所消费cpu是比较久的，这时候要采用多线程效率就低了。 还有IO密集型，线程的任务主要是完成IO操作，所以线程可以利用完成IO的时间，利用cpu 线程状态 线程由进程创建后，会有一定的生命周期，在java中，有以下状态：\nNEW：新建状态，是new了之后，没有后续动作的时候 RUNNABLE：运行状态，是start后，正在运行的时候 BLOCKED：阻塞状态，被动的阻塞了，比如竞争资源失败了 WAITING：等待状态，调用了wait/join之后的状态，这时候必须需要别的线程来呼叫，叫醒这个线程，然后进入运行状态。 TIME_WAITING：超时等待状态，调用了sleep之后的状态，需要别人来叫醒，或者自然醒。 TERMINATED：死亡状态，终止状态，run方法结束之后的状态。 阻塞和等待 阻塞状态：\n这是线程去竞争临界区的锁失败后的状态 之后，还可以去竞争，继续运行 等待状态：\n这是线程主动等待，释放锁，也就代表释放占用的资源了。 这都是获取到锁之后，才能去操作的。 线程死锁 死锁：\n多个线程都处于阻塞状态，程序无法停止；如多个线程都在竞争某些资源，但是这些资源都被互相占用着，都不释放，所以线程都处于阻塞状态。 条件：\n互斥条件：针对资源，一个资源任意时刻只有一个线程占有 请求与保持条件：针对线程，一个线程因请求资源而阻塞时，对已获得的资源保持不放 不剥夺条件：针对资源，线程在占有资源的时候，不允许其他线程占有 循环等待条件：针对线程，多个线程按照顺序申请资源，前一个不释放，后一个也就不能占有 创建和使用线程Runnable 接口，是一个功能性接口 可以自定义一个类实现接口，然后重写run方法，传入一个Thread构造器中，然后调用start方法，达到创建线程，执行任务的功能 public interface Runnable{ void run(); } Thread 这个是java中创建和使用线程的类 它实现了Runnable接口 start()和run() start才是线程开启工作的方法，它最后调用的是一个native方法 run方法只是线程启动后，具体的工作内容，它是由java虚拟机来调用 使用\n类中有很多构造器，有一个Runnable参数的构造器 如果创建对象不传参数，类中的target（runnable）是null 传参，就调用参数的run方法 Thread类中的run方法默认调用的是类中成员target（runnable）的方法 所以，要重写run方法 新建一个类，实现接口，重写方法 继承Thread类，重写方法 使用匿名类，重写方法 public class Thread implements Runnable { Runnable target; public Thread(){ this.target=null; } public void run(){ if (target != null) { target.run(); } } public synchronized void start() { start0(); } private native void start0(); } wait() 这是Object类中的方法，它的作用是让当前线程进入等待状态，当前线程会被置于这个对象的等待集合中，线程调度时会被禁用。 该方法只能由此对象的监视器进行调用，否则会抛出IllegalMonitorStateException异常 如果当前线程在等待之前或在等待时被任何线程中断，则会抛出 InterruptedException 异常 它应该被用在同步代码块/同步方法中，这也就说明wait方法是获取了锁之后才会调用的 wait(0)是永久等待，wait(10)是等待10毫秒也就是放弃10秒对象的同步权 线程苏醒的时机：\n其他线程调用对象的notify方法并且等待的线程恰好是要唤醒的线程(notify是随机的) 其他线程调用对象的notifyAll方法 其他线程中断等待的线程，出现异常 指定的时间到了 苏醒之后，是将对象的等待集合中删除该线程，然后，该线程重新竞争对象的同步权\n使用：\n线程竞争资源，争锁，竞争成功这执行锁块的代码，竞争失败进入对象监视器的等待队列 竞争成功后可以调用wait方法（可能是因为这功能需要其他的条件才能执行，条件不符合的时候主动等待一下，等待条件符合） 其他线程也会竞争资源，但是总会有符合条件，执行功能代码的线程，所以此时成功执行功能代码的线程就可以唤醒某一个线程，但是注意，此时有可能会唤醒多个等待线程（比如notifyAll方法，或者循环几次调用notify方法……） 被唤醒的线程会重新竞争资源，但还是会有新线程会竞争资源 最终，竞争成功的线程会根据程序计数器记录的位置继续执行代码块 但是存在以下问题：虚假唤醒 线程可以在没有通知、中断或超时的情况下被唤醒，这就是所谓的虚假唤醒 这时候被唤醒，就会去执行功能代码块，但是条件没有通过其他线程正确的修改，所以就会有问题 所以采用循环的方式，将wait放在循环里面，以免这种情况 所以最终线程执行功能代码，不仅取决于竞争锁成功（也就是获得cpu使用权），而且也要符合某个执行条件 String a=\"12\"; Thread t=new Thread(new Runnable() { public void run() { synchronized (a){ System.out.println(this); while(!locked){ try { a.wait(); } catch (InterruptedException e) { throw new RuntimeException(e); } } } } }); t.start(); notify()/notifyAll() 属于Object类的方法，即每个类都有这个方法 作用是将对象的监视器的等待队列的线程移除，恢复其重新竞争的状态。 注意，和wait方法一样，调用对象的这两个方法，必须要有这个对象的监视器的所有权 sleep() 使当前线程暂时停止执行，在指定的时间之后恢复继续运行 注意，它不会使线程失去认识监视器的所有权 Thread 类的静态本地方法 join() 这个是属于线程的方法，当前线程可以调用另一个线程的join方法，使它进入等待状态， 具体的方式是 应用在线程对象的wait方法，比如A、B两个线程，B线程调用A.join() 此时B线程只有等到A线程死亡之后，才会退出循环继续执行代码 public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis == 0) { while (isAlive()) { wait(0); } } else { while (isAlive()) { long delay = millis - now; if (delay \u003c= 0) { break; } wait(delay); now = System.currentTimeMillis() - base; } } } isAlive是native方法，用于检查线程是否存活 并发编程的特性","悲观锁和乐观锁#悲观锁和乐观锁":"悲观锁：\n假设所有的情况都是最糟糕的，所以在每个线程竞争资源的时候都会上锁，竞争失败的话就阻塞，加入到等待队列，唤醒的时候，进行线程切换。 适用于数据冲突频繁的场景 如synchronized、ReentrantLock都是悲观锁 乐观锁：\n假设当前的资源没有任何问题，继续操作，在更新数据的时候进行检查对错与否 适用于数据冲突少的场景 比如CAS操作 ","有序性#有序性":" 程序的执行顺序应该按照代码编写的先后顺序来执行，即使在并发环境下也应如此。这样可以保证程序的正确性和预期的行为。 ","用户线程内核线程#用户线程/内核线程":"","线程#线程":"","线程模型#线程模型":"","线程死锁#线程死锁":"","线程状态#线程状态":"","进程#进程":"","进程线程#进程/线程":"","问题#问题":"主要问题就是多个线程去竞争一个共享资源的时候，会出现混乱，比如一个线程修改了这个资源，另一个线程也去修改了这个资源，在回写保存的时候，其中一个线程修改的操作会被覆盖掉。 这个时候，就要考虑线程之间的同步性了。回忆一下操作系统的信号量机制，信号量是一个抽象的数据类型，通常包括一个整型数和一个等待队列，利用PV操作，请求资源、释放资源，常见的有整型信号量、记录型信号量，利用信号量(mutex)的值，来决定该线程是否能获得这个共享资源，获得不了就阻塞加入到等待队列，其他线程释放资源的时候，就从等待队列中释放相应数量的阻塞线程。\n注意哦，对象的监视器就类似操作系统的那个记录型信号量机制，一个整型数、一个等待队列（对应的对象的等待队列）"},"title":"基础概念"},"/java/thread/pool/":{"data":{"callable#Callable":"","executors#Executors":"","executorservice#ExecutorService":"","executor接口#Executor接口":"","future#Future":"","threadpoolexecutor#ThreadPoolExecutor":"","任务队列排队用的#\u003cstrong\u003e任务队列（排队用的）\u003c/strong\u003e":"线程池 池化技术，对于线程来说，在一个池中存放许多线程对象，当来一个任务的时候，不需要创建新的线程对象，而是直接从池中拿一个线程对象来使用，进行处理任务 好处：\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。 Executor接口 用来在未来某个时间执行Runnable的任务 执行程序可以在调用者的线程中立即运行已提交的任务，当然也可以在execute方法中新开一个线程执行run方法 public class ExecutorOne implements Executor { @Override public void execute(Runnable command) { command.run(); } public static void main(String[] args) { ExecutorOne exec = new ExecutorOne(); exec.execute(()-\u003e System.out.println(\"hello,world！\")); } } Callable @FunctionalInterface public interface Callable\u003cV\u003e { //计算结果，无法计算抛出异常 V call() throws Exception; } 和Runnable类似，但Runnable无法返回结果 该接口提供了一个call的动作，所以任何实现该接口的类，都会有这一个动作，此时可以结合其他类，利用实现Callable接口的类做一些功能，如果结合线程，就可以不占用主线程做一些异步任务，并且可以获取计算的结果，挺好！ Future public interface Future\u003cV\u003e { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; } 代表的是异步计算的结果，允许程序员对异步执行的任务进行控制和获取结果 接口的功能主要关注的是任务的结果，和Runnable不同，Runnable只有一个run方法，只是可以利用线程完成一系列不关心结果的任务 ExecutorService public interface ExecutorService extends Executor { void shutdown(); List\u003cRunnable\u003e shutdownNow(); boolean isShutdown(); boolean isTerminated(); //执行一个任务 \u003cT\u003e Future\u003cT\u003e submit(Callable\u003cT\u003e task); \u003cT\u003e Future\u003cT\u003e submit(Runnable task, T result); Future\u003c?\u003e submit(Runnable task); //执行所有的任务 \u003cT\u003e List\u003cFuture\u003cT\u003e\u003e invokeAll(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks) throws InterruptedException; //执行一个成功的任务 \u003cT\u003e T invokeAny(Collection\u003c? extends Callable\u003cT\u003e\u003e tasks) throws InterruptedException, ExecutionException; } 本质上是一个为异步任务执行提供机制的接口，从接口定义的动作来看，就是为了执行任务，并且返回任务计算的结果的。 ThreadPoolExecutor 是一个线程池的实现框架，它通过几个重要的参数来定义池中的信息，用以控制线程的信息 类名的意思应该是，最顶层接口是一个Executor，它用来执行一个任务，然后这个类代表的是用一个线程池来执行很多的任务 参数 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u003cRunnable\u003e workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) { if (corePoolSize \u003c 0 || maximumPoolSize \u003c= 0 || maximumPoolSize \u003c corePoolSize || keepAliveTime \u003c 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null :AccessController.getContext(); } corePoolSize – 线程池的核心线程数量 maximumPoolSize – 线程池的最大线程数量 keepAliveTime –当线程数大于核心线程数时，空闲线程的等待任务的时间，时间一过，终止线程 unit – 时间单位 workQueue – 保存未执行的任务。仅仅保存由execute方法执行的Runnable任务 threadFactory – 创建新线程的工厂 handler – 拒绝执行策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务 线程数量的控制 新任务来时，判断当前运行的线程数量 小于corePoolSize，则创建新线程 [corePoolSize，maximumPoolSize)，判断任务队列 任务队列没满，继续等待 任务队列满，创建新线程 当然也可以使用方法，在接收任务之前，预先创建核心线程 拒绝策略 当任务队列满，且线程数量达到最大，新的任务将被拒绝 public interface RejectedExecutionHandler { void rejectedExecution(Runnable r, ThreadPoolExecutor executor); } 在该类中定义了四个静态内部类，用于拒绝策略\nAbortPolicy：直接拒绝新任务，直接抛出RejectedExecutionException异常，（默认的） CallerRunsPolicy：直接由调用execute方法的线程来执行Runnable的run方法，这种情况是每个任务都得到执行 DiscardOldestPolicy：任务队列的队头丢弃，然后新的任务执行execute，进行原来的判断处理 DiscardPolicy：直接丢弃，也就是不做任何处理，空方法体 任务队列（排队用的） public interface BlockingQueue\u003cE\u003e extends Queue\u003cE\u003e { boolean add(E e); boolean offer(E e); void put(E e) throws InterruptedException; boolean remove(Object o); E poll()throws InterruptedException; E take() throws InterruptedException; } 该类的排队采用是一种阻塞队列，先进先出的数据结构 阻塞队列是支持线程插入/删除元素失败的线程等待作用，类似与生产者/消费者。 因为阻塞队列是不竞争资源的，不需要阻塞，而是放弃cpu的使用权，进入等待状态，等待某个条件的成立而恢复操作（如队列有空间可以使用了） ArrayBlockingQueue 数组支持的有界阻塞队列 新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素 数组大小固定 数组满时，插入线程等待 数组空时，移除线程等待 注意：\n阻塞功能要用put/offer方法，add方法会抛出异常 此类是线程安全的，采用了可重入锁ReentrantLock来维护 DelayQueue 是一个无界阻塞队列，底层采用的是优先队列 延迟：是指队列中的元素必须经过指定时间之后，才能取出来 队列中的元素必须实现Delayed接口，支持队列中的排序和延迟功能。 public class DelayQueue\u003cE extends Delayed\u003e extends AbstractQueue\u003cE\u003e implements BlockingQueue\u003cE\u003e { } SynchronousQueue 同步阻塞队列，每个插入操作必须等待另一个线程的对应移除操作 ；可以理解为：一个生产者添加一个元素，它若想停止必须等待一个消费者取出这个元素，类似于消息的安全传递 注意：该队列没有任何元素 适合于传递性设计，在这种设计中，在一个线程中运行的对象要将某些信息、事件或任务传递给在另一个线程中运行的对象，它就必须与该对象同步。 使用：\n只有put、take、offer、poll有用，其他的关于集合的动作都是没用的 如下例，生产者线程会一直等待下去 public class Example { public static void main(String[] args) throws InterruptedException { SynchronousQueue\u003cInteger\u003e queue = new SynchronousQueue\u003c\u003e(); // 生产者线程 new Thread(() -\u003e { try { queue.put(1); // 向队列中添加元素 } catch (InterruptedException e) { e.printStackTrace(); } }).start(); } } ","参数#参数":"","拒绝策略#\u003cstrong\u003e拒绝策略\u003c/strong\u003e":"","线程数量的控制#\u003cstrong\u003e线程数量的控制\u003c/strong\u003e":"","线程池#线程池":"","辅助接口和类#辅助接口和类":""},"title":"线程池"},"/post/":{"data":{"":""},"title":"Posts"},"/post/java/":{"data":{"简介#简介":"简介","配置#配置":" public class Main{ public static void main(String[]args){ int a=1; } } "},"title":"Java"},"/post/readme/":{"data":{"这是hugo的第一个文章#这是Hugo的第一个文章":"这是Hugo的第一个文章"},"title":"hello"}}